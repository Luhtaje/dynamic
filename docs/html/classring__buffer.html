<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DynamicRingBuffer: ring_buffer&lt; T, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DynamicRingBuffer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classring__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ring_buffer&lt; T, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Dynamic Ringbuffer is a dynamically growing std::container with support for queue, stack and priority queue adaptor functionality.  
 <a href="classring__buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ring__buffer_8hpp_source.html">ring_buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">_rBuf_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom iterator class.  <a href="classring__buffer_1_1__r_buf__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">_rBuf_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom iterator class.  <a href="classring__buffer_1_1__r_buf__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a86bb7fcf18efac4fd9392b0d1e7936e2"><td class="memItemLeft" align="right" valign="top"><a id="a86bb7fcf18efac4fd9392b0d1e7936e2" name="a86bb7fcf18efac4fd9392b0d1e7936e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a86bb7fcf18efac4fd9392b0d1e7936e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba882483fe1804a86e9050edaf246f2"><td class="memItemLeft" align="right" valign="top"><a id="a0ba882483fe1804a86e9050edaf246f2" name="a0ba882483fe1804a86e9050edaf246f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="separator:a0ba882483fe1804a86e9050edaf246f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad513971955235a51282d9c51f6734fe7"><td class="memItemLeft" align="right" valign="top"><a id="ad513971955235a51282d9c51f6734fe7" name="ad513971955235a51282d9c51f6734fe7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = T &amp;</td></tr>
<tr class="separator:ad513971955235a51282d9c51f6734fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca2866bc954c6d9feed98e06b480244"><td class="memItemLeft" align="right" valign="top"><a id="adca2866bc954c6d9feed98e06b480244" name="adca2866bc954c6d9feed98e06b480244"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const T &amp;</td></tr>
<tr class="separator:adca2866bc954c6d9feed98e06b480244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdf728b5383f55939236b958dbdc6e9"><td class="memItemLeft" align="right" valign="top"><a id="a6cdf728b5383f55939236b958dbdc6e9" name="a6cdf728b5383f55939236b958dbdc6e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = T *</td></tr>
<tr class="separator:a6cdf728b5383f55939236b958dbdc6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3d9241f27d43d0bb84fec76da2409"><td class="memItemLeft" align="right" valign="top"><a id="ae7a3d9241f27d43d0bb84fec76da2409" name="ae7a3d9241f27d43d0bb84fec76da2409"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const T *</td></tr>
<tr class="separator:ae7a3d9241f27d43d0bb84fec76da2409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bb2a577a8bc997739a848ab3efd0f9"><td class="memItemLeft" align="right" valign="top"><a id="af9bb2a577a8bc997739a848ab3efd0f9" name="af9bb2a577a8bc997739a848ab3efd0f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = ptrdiff_t</td></tr>
<tr class="separator:af9bb2a577a8bc997739a848ab3efd0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc06ed4cdcd7970b6df48248af49ced"><td class="memItemLeft" align="right" valign="top"><a id="abdc06ed4cdcd7970b6df48248af49ced" name="abdc06ed4cdcd7970b6df48248af49ced"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="separator:abdc06ed4cdcd7970b6df48248af49ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5201496780447d1b83c9648e07752af"><td class="memItemLeft" align="right" valign="top"><a id="aa5201496780447d1b83c9648e07752af" name="aa5201496780447d1b83c9648e07752af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classring__buffer_1_1__r_buf__iterator.html">_rBuf_iterator</a>&lt; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:aa5201496780447d1b83c9648e07752af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a1ec5234f371d755ec75bfd9adafea"><td class="memItemLeft" align="right" valign="top"><a id="af9a1ec5234f371d755ec75bfd9adafea" name="af9a1ec5234f371d755ec75bfd9adafea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">_rBuf_const_iterator</a>&lt; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:af9a1ec5234f371d755ec75bfd9adafea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4c92d2b89348303d05286347c7f66e"><td class="memItemLeft" align="right" valign="top"><a id="a1b4c92d2b89348303d05286347c7f66e" name="a1b4c92d2b89348303d05286347c7f66e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a1b4c92d2b89348303d05286347c7f66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9412feef29dc7e6e73b380578691a3"><td class="memItemLeft" align="right" valign="top"><a id="afb9412feef29dc7e6e73b380578691a3" name="afb9412feef29dc7e6e73b380578691a3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:afb9412feef29dc7e6e73b380578691a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f9101235ae01592332386c047e17d0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3f9101235ae01592332386c047e17d0d">ring_buffer</a> ()</td></tr>
<tr class="memdesc:a3f9101235ae01592332386c047e17d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Constructs to 0 size and 2 capacity.  <a href="classring__buffer.html#a3f9101235ae01592332386c047e17d0d">More...</a><br /></td></tr>
<tr class="separator:a3f9101235ae01592332386c047e17d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4995dd6a70c19f3fb90e17a3c0d2daa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4995dd6a70c19f3fb90e17a3c0d2daa4">ring_buffer</a> (const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:a4995dd6a70c19f3fb90e17a3c0d2daa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with a custom allocator to 0 size and 2 capacity.  <a href="classring__buffer.html#a4995dd6a70c19f3fb90e17a3c0d2daa4">More...</a><br /></td></tr>
<tr class="separator:a4995dd6a70c19f3fb90e17a3c0d2daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2449de34e9c4a70e81c5c76a1a75e71f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a2449de34e9c4a70e81c5c76a1a75e71f">ring_buffer</a> (size_type count, const_reference val, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a2449de34e9c4a70e81c5c76a1a75e71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the buffer to a given size with given values and optionally a custom allocator.  <a href="classring__buffer.html#a2449de34e9c4a70e81c5c76a1a75e71f">More...</a><br /></td></tr>
<tr class="separator:a2449de34e9c4a70e81c5c76a1a75e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2648ee9dbe34781862260df46ac0d1e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a2648ee9dbe34781862260df46ac0d1e5">ring_buffer</a> (size_type count, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a2648ee9dbe34781862260df46ac0d1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom constructor. Initializes a buffer to a capacity without constructing any elemen.  <a href="classring__buffer.html#a2648ee9dbe34781862260df46ac0d1e5">More...</a><br /></td></tr>
<tr class="separator:a2648ee9dbe34781862260df46ac0d1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558ef45f751987abbdd4f458d0efb9a3"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a558ef45f751987abbdd4f458d0efb9a3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a558ef45f751987abbdd4f458d0efb9a3">ring_buffer</a> (InputIt beginIt, InputIt endIt)</td></tr>
<tr class="memdesc:a558ef45f751987abbdd4f458d0efb9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the buffer from range [begin,end).  <a href="classring__buffer.html#a558ef45f751987abbdd4f458d0efb9a3">More...</a><br /></td></tr>
<tr class="separator:a558ef45f751987abbdd4f458d0efb9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37abccd052de210c36f6f397cd841a93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a37abccd052de210c36f6f397cd841a93">ring_buffer</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a37abccd052de210c36f6f397cd841a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list contructor.  <a href="classring__buffer.html#a37abccd052de210c36f6f397cd841a93">More...</a><br /></td></tr>
<tr class="separator:a37abccd052de210c36f6f397cd841a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8925b041c137104b31c975169dd05b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ad8925b041c137104b31c975169dd05b0">ring_buffer</a> (const <a class="el" href="classring__buffer.html">ring_buffer</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad8925b041c137104b31c975169dd05b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classring__buffer.html#ad8925b041c137104b31c975169dd05b0">More...</a><br /></td></tr>
<tr class="separator:ad8925b041c137104b31c975169dd05b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232425cc3a36aeb1a844956fd93623f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a232425cc3a36aeb1a844956fd93623f0">ring_buffer</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a232425cc3a36aeb1a844956fd93623f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classring__buffer.html#a232425cc3a36aeb1a844956fd93623f0">More...</a><br /></td></tr>
<tr class="separator:a232425cc3a36aeb1a844956fd93623f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba67a9f961ab436428b0710cd1af773"><td class="memItemLeft" align="right" valign="top"><a id="adba67a9f961ab436428b0710cd1af773" name="adba67a9f961ab436428b0710cd1af773"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~ring_buffer</b> ()</td></tr>
<tr class="memdesc:adba67a9f961ab436428b0710cd1af773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adba67a9f961ab436428b0710cd1af773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9bf60beea284ff8ec7288526fbe95f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a6e9bf60beea284ff8ec7288526fbe95f">insert</a> (<a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> pos, const value_type &amp;value)</td></tr>
<tr class="memdesc:a6e9bf60beea284ff8ec7288526fbe95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element to the buffer.  <a href="classring__buffer.html#a6e9bf60beea284ff8ec7288526fbe95f">More...</a><br /></td></tr>
<tr class="separator:a6e9bf60beea284ff8ec7288526fbe95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af647fe55fa023f8b9b6e948350c09ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#af647fe55fa023f8b9b6e948350c09ffe">insert</a> (<a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> pos, value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:af647fe55fa023f8b9b6e948350c09ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element to the buffer.  <a href="classring__buffer.html#af647fe55fa023f8b9b6e948350c09ffe">More...</a><br /></td></tr>
<tr class="separator:af647fe55fa023f8b9b6e948350c09ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dccabe03199fe8f651cdeb92ec36aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a36dccabe03199fe8f651cdeb92ec36aa">insert</a> (<a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> pos, const size_type amount, const value_type &amp;value)</td></tr>
<tr class="memdesc:a36dccabe03199fe8f651cdeb92ec36aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element to the buffer.  <a href="classring__buffer.html#a36dccabe03199fe8f651cdeb92ec36aa">More...</a><br /></td></tr>
<tr class="separator:a36dccabe03199fe8f651cdeb92ec36aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68cc324f43afbaef53a5f6dec8e8f79"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:ab68cc324f43afbaef53a5f6dec8e8f79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ab68cc324f43afbaef53a5f6dec8e8f79">insert</a> (<a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> pos, InputIt sourceBegin, InputIt sourceEnd)</td></tr>
<tr class="memdesc:ab68cc324f43afbaef53a5f6dec8e8f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a range of elements into the buffer to a specific position.  <a href="classring__buffer.html#ab68cc324f43afbaef53a5f6dec8e8f79">More...</a><br /></td></tr>
<tr class="separator:ab68cc324f43afbaef53a5f6dec8e8f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0d87d9c657e5356151da13ab78e444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#acd0d87d9c657e5356151da13ab78e444">insert</a> (<a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> pos, std::initializer_list&lt; T &gt; list)</td></tr>
<tr class="memdesc:acd0d87d9c657e5356151da13ab78e444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts initializer list into buffer to a specific position.  <a href="classring__buffer.html#acd0d87d9c657e5356151da13ab78e444">More...</a><br /></td></tr>
<tr class="separator:acd0d87d9c657e5356151da13ab78e444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefe57c42e075e935c20a4da038b7df7"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:acefe57c42e075e935c20a4da038b7df7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#acefe57c42e075e935c20a4da038b7df7">emplace</a> (<a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acefe57c42e075e935c20a4da038b7df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element in place from arguments.  <a href="classring__buffer.html#acefe57c42e075e935c20a4da038b7df7">More...</a><br /></td></tr>
<tr class="separator:acefe57c42e075e935c20a4da038b7df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e65ec20452b89d10f1a587fa39222"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4a7e65ec20452b89d10f1a587fa39222"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4a7e65ec20452b89d10f1a587fa39222">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4a7e65ec20452b89d10f1a587fa39222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in place to front from argumets.  <a href="classring__buffer.html#a4a7e65ec20452b89d10f1a587fa39222">More...</a><br /></td></tr>
<tr class="separator:a4a7e65ec20452b89d10f1a587fa39222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed98662b3760dac1c9ea6c98d0106068"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aed98662b3760dac1c9ea6c98d0106068"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aed98662b3760dac1c9ea6c98d0106068">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aed98662b3760dac1c9ea6c98d0106068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in place to front from argumets.  <a href="classring__buffer.html#aed98662b3760dac1c9ea6c98d0106068">More...</a><br /></td></tr>
<tr class="separator:aed98662b3760dac1c9ea6c98d0106068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68227da7f12db1402a6bce1cc8b834a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ad68227da7f12db1402a6bce1cc8b834a">erase</a> (<a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ad68227da7f12db1402a6bce1cc8b834a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element at a given position.  <a href="classring__buffer.html#ad68227da7f12db1402a6bce1cc8b834a">More...</a><br /></td></tr>
<tr class="separator:ad68227da7f12db1402a6bce1cc8b834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c5e76881f854c9083ae3ea0083a3ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a36c5e76881f854c9083ae3ea0083a3ea">erase</a> (<a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> first, <a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:a36c5e76881f854c9083ae3ea0083a3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the specified elements from the container according to the range [first,last). Might destroy or move assign to the elements depending if last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>. If last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>, elements in [first,last) are destroyed.  <a href="classring__buffer.html#a36c5e76881f854c9083ae3ea0083a3ea">More...</a><br /></td></tr>
<tr class="separator:a36c5e76881f854c9083ae3ea0083a3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a41fdbb783e1acf736ab5b3d154472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a69a41fdbb783e1acf736ab5b3d154472">clear</a> () noexcept</td></tr>
<tr class="memdesc:a69a41fdbb783e1acf736ab5b3d154472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all elements in a buffer. Does not modify capacity.  <a href="classring__buffer.html#a69a41fdbb783e1acf736ab5b3d154472">More...</a><br /></td></tr>
<tr class="separator:a69a41fdbb783e1acf736ab5b3d154472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff5b379f041a4f7ff1cfc8a2a8f69c5"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a2ff5b379f041a4f7ff1cfc8a2a8f69c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a2ff5b379f041a4f7ff1cfc8a2a8f69c5">assign</a> (InputIt sourceBegin, InputIt sourceEnd)</td></tr>
<tr class="memdesc:a2ff5b379f041a4f7ff1cfc8a2a8f69c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the elements in the buffer with copy of [sourceBegin, sourceEnd)  <a href="classring__buffer.html#a2ff5b379f041a4f7ff1cfc8a2a8f69c5">More...</a><br /></td></tr>
<tr class="separator:a2ff5b379f041a4f7ff1cfc8a2a8f69c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5e7138c98dc161fad55891ec10a35b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#acf5e7138c98dc161fad55891ec10a35b">assign</a> (std::initializer_list&lt; T &gt; list)</td></tr>
<tr class="memdesc:acf5e7138c98dc161fad55891ec10a35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the elements in the buffer.  <a href="classring__buffer.html#acf5e7138c98dc161fad55891ec10a35b">More...</a><br /></td></tr>
<tr class="separator:acf5e7138c98dc161fad55891ec10a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacccdd4522868dc3549ac9c7c0bed128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aacccdd4522868dc3549ac9c7c0bed128">assign</a> (const size_type amount, value_type value)</td></tr>
<tr class="memdesc:aacccdd4522868dc3549ac9c7c0bed128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the elements in the buffer with given value.  <a href="classring__buffer.html#aacccdd4522868dc3549ac9c7c0bed128">More...</a><br /></td></tr>
<tr class="separator:aacccdd4522868dc3549ac9c7c0bed128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff7619acabb085c8a582dd02c0737cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#abff7619acabb085c8a582dd02c0737cb">operator=</a> (const <a class="el" href="classring__buffer.html">ring_buffer</a> &amp;other)</td></tr>
<tr class="memdesc:abff7619acabb085c8a582dd02c0737cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classring__buffer.html#abff7619acabb085c8a582dd02c0737cb">More...</a><br /></td></tr>
<tr class="separator:abff7619acabb085c8a582dd02c0737cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e98268d8b4fc82a786f32c000b78018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3e98268d8b4fc82a786f32c000b78018">operator=</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3e98268d8b4fc82a786f32c000b78018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classring__buffer.html#a3e98268d8b4fc82a786f32c000b78018">More...</a><br /></td></tr>
<tr class="separator:a3e98268d8b4fc82a786f32c000b78018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b1641644c85ff869a2458ee6e2912f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ac8b1641644c85ff869a2458ee6e2912f">operator=</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:ac8b1641644c85ff869a2458ee6e2912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list assign operator.  <a href="classring__buffer.html#ac8b1641644c85ff869a2458ee6e2912f">More...</a><br /></td></tr>
<tr class="separator:ac8b1641644c85ff869a2458ee6e2912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c14c9afba67aad502b36653d1bbc2ca"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a7c14c9afba67aad502b36653d1bbc2ca">operator[]</a> (const size_type logicalIndex) noexcept</td></tr>
<tr class="memdesc:a7c14c9afba67aad502b36653d1bbc2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index operator.  <a href="classring__buffer.html#a7c14c9afba67aad502b36653d1bbc2ca">More...</a><br /></td></tr>
<tr class="separator:a7c14c9afba67aad502b36653d1bbc2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbae1471c094bf84d8f1950a525e513"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3bbae1471c094bf84d8f1950a525e513">operator[]</a> (const size_type logicalIndex) const noexcept</td></tr>
<tr class="memdesc:a3bbae1471c094bf84d8f1950a525e513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index operator.  <a href="classring__buffer.html#a3bbae1471c094bf84d8f1950a525e513">More...</a><br /></td></tr>
<tr class="separator:a3bbae1471c094bf84d8f1950a525e513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb085b3f95fdedb1906f4fb9f22c8f"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a15eb085b3f95fdedb1906f4fb9f22c8f">at</a> (size_type logicalIndex)</td></tr>
<tr class="memdesc:a15eb085b3f95fdedb1906f4fb9f22c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific element of the buffer with bounds checking.  <a href="classring__buffer.html#a15eb085b3f95fdedb1906f4fb9f22c8f">More...</a><br /></td></tr>
<tr class="separator:a15eb085b3f95fdedb1906f4fb9f22c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988f02984769a27167341843f36060a4"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a988f02984769a27167341843f36060a4">at</a> (size_type logicalIndex) const</td></tr>
<tr class="memdesc:a988f02984769a27167341843f36060a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific element of the buffer.  <a href="classring__buffer.html#a988f02984769a27167341843f36060a4">More...</a><br /></td></tr>
<tr class="separator:a988f02984769a27167341843f36060a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53ef9bfdabd3a5e613413b27c66de61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aa53ef9bfdabd3a5e613413b27c66de61">swap</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aa53ef9bfdabd3a5e613413b27c66de61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member swap implementation. Swaps RingBuffers member to member.  <a href="classring__buffer.html#aa53ef9bfdabd3a5e613413b27c66de61">More...</a><br /></td></tr>
<tr class="separator:aa53ef9bfdabd3a5e613413b27c66de61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b078b39ae40a0c1bc0b4e60a81f67ac"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a5b078b39ae40a0c1bc0b4e60a81f67ac">data</a> ()</td></tr>
<tr class="memdesc:a5b078b39ae40a0c1bc0b4e60a81f67ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts ringbuffer so that logical tail matches the first element in physical memory.  <a href="classring__buffer.html#a5b078b39ae40a0c1bc0b4e60a81f67ac">More...</a><br /></td></tr>
<tr class="separator:a5b078b39ae40a0c1bc0b4e60a81f67ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0782fc0b1264ff01c5ffbe199423a5"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5">size</a> () const noexcept</td></tr>
<tr class="memdesc:aca0782fc0b1264ff01c5ffbe199423a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the container.  <a href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5">More...</a><br /></td></tr>
<tr class="separator:aca0782fc0b1264ff01c5ffbe199423a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09435a2152f9b680154e1e51e4472787"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a09435a2152f9b680154e1e51e4472787">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a09435a2152f9b680154e1e51e4472787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the theoretical maximum size of the container.  <a href="classring__buffer.html#a09435a2152f9b680154e1e51e4472787">More...</a><br /></td></tr>
<tr class="separator:a09435a2152f9b680154e1e51e4472787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb98388fa6ae8a7a86e968d95534c8fd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aeb98388fa6ae8a7a86e968d95534c8fd">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:aeb98388fa6ae8a7a86e968d95534c8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity getter.  <a href="classring__buffer.html#aeb98388fa6ae8a7a86e968d95534c8fd">More...</a><br /></td></tr>
<tr class="separator:aeb98388fa6ae8a7a86e968d95534c8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ba7169a95db0c12da90173963c2f9"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a527ba7169a95db0c12da90173963c2f9">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a527ba7169a95db0c12da90173963c2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator getter.  <a href="classring__buffer.html#a527ba7169a95db0c12da90173963c2f9">More...</a><br /></td></tr>
<tr class="separator:a527ba7169a95db0c12da90173963c2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e1113807a6554022cee5af36d3e1f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aa8e1113807a6554022cee5af36d3e1f0">empty</a> () const noexcept</td></tr>
<tr class="memdesc:aa8e1113807a6554022cee5af36d3e1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if buffer is empty.  <a href="classring__buffer.html#aa8e1113807a6554022cee5af36d3e1f0">More...</a><br /></td></tr>
<tr class="separator:aa8e1113807a6554022cee5af36d3e1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6fd7a2d343de27c99761c6029f6d28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a8f6fd7a2d343de27c99761c6029f6d28">reserve</a> (size_type newCapacity, bool enableShrink=false)</td></tr>
<tr class="memdesc:a8f6fd7a2d343de27c99761c6029f6d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory and copies the existing buffer to the new memory location. Can be used to increase or decrease capacity.  <a href="classring__buffer.html#a8f6fd7a2d343de27c99761c6029f6d28">More...</a><br /></td></tr>
<tr class="separator:a8f6fd7a2d343de27c99761c6029f6d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bed0fe915650f882f772d022f89bc0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4bed0fe915650f882f772d022f89bc0b">push_front</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:a4bed0fe915650f882f772d022f89bc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the back of the buffer. If buffer would get full after the operation, allocates more memory.  <a href="classring__buffer.html#a4bed0fe915650f882f772d022f89bc0b">More...</a><br /></td></tr>
<tr class="separator:a4bed0fe915650f882f772d022f89bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d27891d77e19442f1d8acaa26b11ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ab2d27891d77e19442f1d8acaa26b11ee">push_front</a> (value_type &amp;&amp;val)</td></tr>
<tr class="memdesc:ab2d27891d77e19442f1d8acaa26b11ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the back of the buffer by move if move constructor is provided by value_type. If buffer would get full after the operation, allocates more memory.  <a href="classring__buffer.html#ab2d27891d77e19442f1d8acaa26b11ee">More...</a><br /></td></tr>
<tr class="separator:ab2d27891d77e19442f1d8acaa26b11ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de0c8df71d288b2948d618bdd930250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3de0c8df71d288b2948d618bdd930250">push_back</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:a3de0c8df71d288b2948d618bdd930250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the back of the buffer. If buffer would get full after the operation, allocates more memory.  <a href="classring__buffer.html#a3de0c8df71d288b2948d618bdd930250">More...</a><br /></td></tr>
<tr class="separator:a3de0c8df71d288b2948d618bdd930250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ed70b4ef81563f9e8d349f256d84c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a7d8ed70b4ef81563f9e8d349f256d84c">push_back</a> (value_type &amp;&amp;val)</td></tr>
<tr class="memdesc:a7d8ed70b4ef81563f9e8d349f256d84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the back of the buffer by move if move constructor is provided for value_type. If buffer would get full after the operation, allocates more memory.  <a href="classring__buffer.html#a7d8ed70b4ef81563f9e8d349f256d84c">More...</a><br /></td></tr>
<tr class="separator:a7d8ed70b4ef81563f9e8d349f256d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef28bc848394b3bc6a1dea129dbb412f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aef28bc848394b3bc6a1dea129dbb412f">pop_front</a> () noexcept</td></tr>
<tr class="memdesc:aef28bc848394b3bc6a1dea129dbb412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first element in the buffer.  <a href="classring__buffer.html#aef28bc848394b3bc6a1dea129dbb412f">More...</a><br /></td></tr>
<tr class="separator:aef28bc848394b3bc6a1dea129dbb412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c703f9814872877775d2a5c2fef243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ad1c703f9814872877775d2a5c2fef243">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:ad1c703f9814872877775d2a5c2fef243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from the logical back of the buffer.  <a href="classring__buffer.html#ad1c703f9814872877775d2a5c2fef243">More...</a><br /></td></tr>
<tr class="separator:ad1c703f9814872877775d2a5c2fef243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4404cf478938dc61b93a963581bd2f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4404cf478938dc61b93a963581bd2f3a">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a4404cf478938dc61b93a963581bd2f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases unused allocated memory.  <a href="classring__buffer.html#a4404cf478938dc61b93a963581bd2f3a">More...</a><br /></td></tr>
<tr class="separator:a4404cf478938dc61b93a963581bd2f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dee6af7622eafe9662e32f10d78b6b6"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a6dee6af7622eafe9662e32f10d78b6b6">front</a> () noexcept</td></tr>
<tr class="memdesc:a6dee6af7622eafe9662e32f10d78b6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the buffer. Behaviour is undefined for empty buffer.  <a href="classring__buffer.html#a6dee6af7622eafe9662e32f10d78b6b6">More...</a><br /></td></tr>
<tr class="separator:a6dee6af7622eafe9662e32f10d78b6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96289837a2a156411bddba7f214cce3a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a96289837a2a156411bddba7f214cce3a">front</a> () const noexcept</td></tr>
<tr class="memdesc:a96289837a2a156411bddba7f214cce3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the buffer. Behaviour is undefined for empty buffer.  <a href="classring__buffer.html#a96289837a2a156411bddba7f214cce3a">More...</a><br /></td></tr>
<tr class="separator:a96289837a2a156411bddba7f214cce3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ca98342bbe89dd9aba19838cb7b407"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ae7ca98342bbe89dd9aba19838cb7b407">back</a> () noexcept</td></tr>
<tr class="memdesc:ae7ca98342bbe89dd9aba19838cb7b407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the buffer. Behaviour is undefined for empty buffer.  <a href="classring__buffer.html#ae7ca98342bbe89dd9aba19838cb7b407">More...</a><br /></td></tr>
<tr class="separator:ae7ca98342bbe89dd9aba19838cb7b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0661379f8b19f49d5e5d026455be9617"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a0661379f8b19f49d5e5d026455be9617">back</a> () const noexcept</td></tr>
<tr class="memdesc:a0661379f8b19f49d5e5d026455be9617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const-reference to the last element in the buffer. Behaviour is undefined for empty buffer.  <a href="classring__buffer.html#a0661379f8b19f49d5e5d026455be9617">More...</a><br /></td></tr>
<tr class="separator:a0661379f8b19f49d5e5d026455be9617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2abcc16c769e390ed5fc16b320cce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4a2abcc16c769e390ed5fc16b320cce7">begin</a> () noexcept</td></tr>
<tr class="memdesc:a4a2abcc16c769e390ed5fc16b320cce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct iterator at begin.  <a href="classring__buffer.html#a4a2abcc16c769e390ed5fc16b320cce7">More...</a><br /></td></tr>
<tr class="separator:a4a2abcc16c769e390ed5fc16b320cce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8347b456303e02b7a9ee23312859a621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a8347b456303e02b7a9ee23312859a621">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a8347b456303e02b7a9ee23312859a621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct const_iterator at begin.  <a href="classring__buffer.html#a8347b456303e02b7a9ee23312859a621">More...</a><br /></td></tr>
<tr class="separator:a8347b456303e02b7a9ee23312859a621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab057216d2bd4ad43454758fb3eeed319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319">end</a> () noexcept</td></tr>
<tr class="memdesc:ab057216d2bd4ad43454758fb3eeed319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct iterator at end.  <a href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319">More...</a><br /></td></tr>
<tr class="separator:ab057216d2bd4ad43454758fb3eeed319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3a0562418674a74bbc28eaa6ca793e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a8b3a0562418674a74bbc28eaa6ca793e">end</a> () const noexcept</td></tr>
<tr class="memdesc:a8b3a0562418674a74bbc28eaa6ca793e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct const_iterator at end.  <a href="classring__buffer.html#a8b3a0562418674a74bbc28eaa6ca793e">More...</a><br /></td></tr>
<tr class="separator:a8b3a0562418674a74bbc28eaa6ca793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9494413971913e7702426e7fe8968c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a9494413971913e7702426e7fe8968c6a">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a9494413971913e7702426e7fe8968c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct const_iterator at begin.  <a href="classring__buffer.html#a9494413971913e7702426e7fe8968c6a">More...</a><br /></td></tr>
<tr class="separator:a9494413971913e7702426e7fe8968c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bce1fcd742096534d78bc450371775a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3bce1fcd742096534d78bc450371775a">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a3bce1fcd742096534d78bc450371775a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct const_iterator pointing to past the last element.  <a href="classring__buffer.html#a3bce1fcd742096534d78bc450371775a">More...</a><br /></td></tr>
<tr class="separator:a3bce1fcd742096534d78bc450371775a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab456f054b5903b00e9b23ecf0b93675d"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ab456f054b5903b00e9b23ecf0b93675d">rbegin</a> ()</td></tr>
<tr class="memdesc:ab456f054b5903b00e9b23ecf0b93675d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reverse iterator pointing to the first element in reverse order (last element in normal order).  <a href="classring__buffer.html#ab456f054b5903b00e9b23ecf0b93675d">More...</a><br /></td></tr>
<tr class="separator:ab456f054b5903b00e9b23ecf0b93675d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa243a80e8756739ce4b64f73e9a4338e"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aa243a80e8756739ce4b64f73e9a4338e">rbegin</a> () const</td></tr>
<tr class="memdesc:aa243a80e8756739ce4b64f73e9a4338e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reverse iterator pointing to the first element in reverse order (last element in normal order).  <a href="classring__buffer.html#aa243a80e8756739ce4b64f73e9a4338e">More...</a><br /></td></tr>
<tr class="separator:aa243a80e8756739ce4b64f73e9a4338e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109b2e943558eab49ca6d33ca398a838"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a109b2e943558eab49ca6d33ca398a838">crbegin</a> () const</td></tr>
<tr class="memdesc:a109b2e943558eab49ca6d33ca398a838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reverse iterator pointing to the first element in reverse order (last element in normal order).  <a href="classring__buffer.html#a109b2e943558eab49ca6d33ca398a838">More...</a><br /></td></tr>
<tr class="separator:a109b2e943558eab49ca6d33ca398a838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ee796bf66742e0d25716ce4c9d6f5d"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a81ee796bf66742e0d25716ce4c9d6f5d">rend</a> ()</td></tr>
<tr class="memdesc:a81ee796bf66742e0d25716ce4c9d6f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order).  <a href="classring__buffer.html#a81ee796bf66742e0d25716ce4c9d6f5d">More...</a><br /></td></tr>
<tr class="separator:a81ee796bf66742e0d25716ce4c9d6f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dcf3f2bfc1c9be3d18ab2d25eebd48"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ae9dcf3f2bfc1c9be3d18ab2d25eebd48">rend</a> () const</td></tr>
<tr class="memdesc:ae9dcf3f2bfc1c9be3d18ab2d25eebd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order).  <a href="classring__buffer.html#ae9dcf3f2bfc1c9be3d18ab2d25eebd48">More...</a><br /></td></tr>
<tr class="separator:ae9dcf3f2bfc1c9be3d18ab2d25eebd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a25432bd918d4cafbfb9e5bd47ea296"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a8a25432bd918d4cafbfb9e5bd47ea296">crend</a> () const</td></tr>
<tr class="memdesc:a8a25432bd918d4cafbfb9e5bd47ea296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order).  <a href="classring__buffer.html#a8a25432bd918d4cafbfb9e5bd47ea296">More...</a><br /></td></tr>
<tr class="separator:a8a25432bd918d4cafbfb9e5bd47ea296"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a15bc4c9d1486b1fcd9b8c5f7956b3d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a15bc4c9d1486b1fcd9b8c5f7956b3d4c">swap</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;a, <a class="el" href="classring__buffer.html">ring_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a15bc4c9d1486b1fcd9b8c5f7956b3d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Friend swap.  <a href="classring__buffer.html#a15bc4c9d1486b1fcd9b8c5f7956b3d4c">More...</a><br /></td></tr>
<tr class="separator:a15bc4c9d1486b1fcd9b8c5f7956b3d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt;<br />
class ring_buffer&lt; T, Allocator &gt;</div><p >Dynamic Ringbuffer is a dynamically growing std::container with support for queue, stack and priority queue adaptor functionality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Allocator used for (de)allocation and (de)construction. Defaults to std::allocator&lt;T&gt; </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3f9101235ae01592332386c047e17d0d" name="a3f9101235ae01592332386c047e17d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9101235ae01592332386c047e17d0d">&#9670;&#160;</a></span>ring_buffer() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;<a class="el" href="classring__buffer.html">::ring_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Constructs to 0 size and 2 capacity. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory available for allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>this-&gt;<a class="el" href="classring__buffer.html#aa8e1113807a6554022cee5af36d3e1f0" title="Check if buffer is empty.">empty()</a> == true. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a4995dd6a70c19f3fb90e17a3c0d2daa4" name="a4995dd6a70c19f3fb90e17a3c0d2daa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4995dd6a70c19f3fb90e17a3c0d2daa4">&#9670;&#160;</a></span>ring_buffer() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;<a class="el" href="classring__buffer.html">::ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with a custom allocator to 0 size and 2 capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Custom allocator for the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>this-&gt;<a class="el" href="classring__buffer.html#aa8e1113807a6554022cee5af36d3e1f0" title="Check if buffer is empty.">empty()</a> == true. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory available for allocation. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a2449de34e9c4a70e81c5c76a1a75e71f" name="a2449de34e9c4a70e81c5c76a1a75e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2449de34e9c4a70e81c5c76a1a75e71f">&#9670;&#160;</a></span>ring_buffer() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;<a class="el" href="classring__buffer.html">::ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the buffer to a given size with given values and optionally a custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Amount of elements to be initialized in the buffer. </td></tr>
    <tr><td class="paramname">val</td><td>Reference to a value which the elements are initialized to. </td></tr>
    <tr><td class="paramname">alloc</td><td>Custom allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T needs to satisfy CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>std::distance(<a class="el" href="classring__buffer.html#a4a2abcc16c769e390ed5fc16b320cce7" title="Construct iterator at begin.">begin()</a>, <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>) == count. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Allocates memory for count + 2 elements. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory available for allocation. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to amount of constructed elements (O(n)). </p>

</div>
</div>
<a id="a2648ee9dbe34781862260df46ac0d1e5" name="a2648ee9dbe34781862260df46ac0d1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2648ee9dbe34781862260df46ac0d1e5">&#9670;&#160;</a></span>ring_buffer() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;<a class="el" href="classring__buffer.html">::ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom constructor. Initializes a buffer to a capacity without constructing any elemen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Capacity of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must satisfy DefaultInsertable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory available for allocation, or some exception from T's constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to count (O(n)). </p>

</div>
</div>
<a id="a558ef45f751987abbdd4f458d0efb9a3" name="a558ef45f751987abbdd4f458d0efb9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558ef45f751987abbdd4f458d0efb9a3">&#9670;&#160;</a></span>ring_buffer() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;<a class="el" href="classring__buffer.html">::ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>beginIt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>endIt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the buffer from range [begin,end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIt</td><td>Iterator to first element of range. </td></tr>
    <tr><td class="paramname">endIt</td><td>Iterator pointing to past-the-last element of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>valye_type must satisfy CopyInsertable. InputIt must be deferencable to value_type, and incrementing rangeBegin (repeatedly) must reach rangeEnd. Otherwise behaviour is undefined. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory available for allocation, or something from T's constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to the size of the range (O(n)). </p><dl class="section note"><dt>Note</dt><dd>Behavior is undefined if elements in range are not valid. </dd></dl>

</div>
</div>
<a id="a37abccd052de210c36f6f397cd841a93" name="a37abccd052de210c36f6f397cd841a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37abccd052de210c36f6f397cd841a93">&#9670;&#160;</a></span>ring_buffer() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;<a class="el" href="classring__buffer.html">::ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list contructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the buffer from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must satisfy CopyInsertable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory for allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Allocates memory for 2 extra elements.</dd></dl>
<p>Linear complexity in relation to initializer list size (O(n)). </p>

</div>
</div>
<a id="ad8925b041c137104b31c975169dd05b0" name="ad8925b041c137104b31c975169dd05b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8925b041c137104b31c975169dd05b0">&#9670;&#160;</a></span>ring_buffer() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;<a class="el" href="classring__buffer.html">::ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Reference to a RingBuffer to create a copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this == <a class="el" href="classring__buffer.html" title="Dynamic Ringbuffer is a dynamically growing std::container with support for queue,...">ring_buffer(rhs)</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory for memory allocation, or something from value_types constructor. @except If any exception is thrown, invariants are preserved.(Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size. </p>

</div>
</div>
<a id="a232425cc3a36aeb1a844956fd93623f0" name="a232425cc3a36aeb1a844956fd93623f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232425cc3a36aeb1a844956fd93623f0">&#9670;&#160;</a></span>ring_buffer() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;<a class="el" href="classring__buffer.html">::ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Rvalue reference to other buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must resolve std::is_nothrow_move_constructible&lt;value_type&gt;::value to true. Otherwise function does nothing.</dd></dl>
<p>Linear complexity in relation to buffer size, unless other's allocator compares equal or is propagated on move assignment, then complexity is Constant. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aacccdd4522868dc3549ac9c7c0bed128" name="aacccdd4522868dc3549ac9c7c0bed128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacccdd4522868dc3549ac9c7c0bed128">&#9670;&#160;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the elements in the buffer with given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>Size of the buffer after the assignment. </td></tr>
    <tr><td class="paramname">value</td><td>Value of all elements after the assignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All existing references, pointers and iterators are to be considered invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is throw, invariants are preserved (Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to ranges size (O(n * 2) from linear clear and linear construction). </p><dl class="section note"><dt>Note</dt><dd>Destroys all elements in the buffer before constructing the assigned elements. </dd></dl>

</div>
</div>
<a id="a2ff5b379f041a4f7ff1cfc8a2a8f69c5" name="a2ff5b379f041a4f7ff1cfc8a2a8f69c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff5b379f041a4f7ff1cfc8a2a8f69c5">&#9670;&#160;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>sourceBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>sourceEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the elements in the buffer with copy of [sourceBegin, sourceEnd) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceBegin</td><td>Iterator to beginning of the range. </td></tr>
    <tr><td class="paramname">sourceEnd</td><td>Past the end iterator of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is CopyInsertable and elements of [sourceBegin, sourceEnd) are not in *this. InputIt must be dereferenceable to value_type, and incrementing sourceBegin (repeatedly) must reach sourceEnd. Otherwise behaviour is undefined. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All existing references, pointers and iterators are to be considered invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is throw, invariants are preserved (Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to ranges size (O(n * 2) from linear clear and linear construction). </p><dl class="section note"><dt>Note</dt><dd>Destroys all elements in the buffer before constructing the assigned elements. </dd></dl>

</div>
</div>
<a id="acf5e7138c98dc161fad55891ec10a35b" name="acf5e7138c98dc161fad55891ec10a35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5e7138c98dc161fad55891ec10a35b">&#9670;&#160;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the elements in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Initializer list containing the elements to replace the existing ones. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is CopyInsertable. List does not contain elements of *this. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All existing references, pointers and iterators are to be considered invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is throw, invariants are preserved (Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to ranges size (O(n * 2) from linear clear and linear construction). </p><dl class="section note"><dt>Note</dt><dd>Destroys all elements in the buffer before constructing the assigned elements. </dd></dl>

</div>
</div>
<a id="a15eb085b3f95fdedb1906f4fb9f22c8f" name="a15eb085b3f95fdedb1906f4fb9f22c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb085b3f95fdedb1906f4fb9f22c8f">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>logicalIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific element of the buffer with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalIndex</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference the the element at index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>std::out_of_range if index is larger or equal to buffers size. </td></tr>
    <tr><td class="paramname">If</td><td>any exceptions is thrown this function has no effect (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a988f02984769a27167341843f36060a4" name="a988f02984769a27167341843f36060a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988f02984769a27167341843f36060a4">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>logicalIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific element of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalIndex</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference the the element at index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>std::out_of_range if index is larger or equal to buffers size. </td></tr>
    <tr><td class="paramname">If</td><td>any exceptions is thrown this function has no effect (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a0661379f8b19f49d5e5d026455be9617" name="a0661379f8b19f49d5e5d026455be9617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0661379f8b19f49d5e5d026455be9617">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const-reference to the last element in the buffer. Behaviour is undefined for empty buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in the buffer.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ae7ca98342bbe89dd9aba19838cb7b407" name="ae7ca98342bbe89dd9aba19838cb7b407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ca98342bbe89dd9aba19838cb7b407">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the buffer. Behaviour is undefined for empty buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element in the buffer.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a8347b456303e02b7a9ee23312859a621" name="a8347b456303e02b7a9ee23312859a621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8347b456303e02b7a9ee23312859a621">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct const_iterator at begin. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator pointing to first element.</dd></dl>
<p>Constant complexity. Iterator is invalid if the buffer is empty (dereferencing points to uninitialized memory.). </p>

</div>
</div>
<a id="a4a2abcc16c769e390ed5fc16b320cce7" name="a4a2abcc16c769e390ed5fc16b320cce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2abcc16c769e390ed5fc16b320cce7">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct iterator at begin. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to first element.</dd></dl>
<p>Constant complexity. Iterator is invalid if the buffer is empty (dereferencing points to uninitialized memory.). </p>

</div>
</div>
<a id="aeb98388fa6ae8a7a86e968d95534c8fd" name="aeb98388fa6ae8a7a86e968d95534c8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb98388fa6ae8a7a86e968d95534c8fd">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Capacity getter. </p>
<dl class="section return"><dt>Returns</dt><dd>m_capacity Returns how many elements have been allocated for the buffers use.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a9494413971913e7702426e7fe8968c6a" name="a9494413971913e7702426e7fe8968c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9494413971913e7702426e7fe8968c6a">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct const_iterator at begin. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator pointing to first element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a3bce1fcd742096534d78bc450371775a" name="a3bce1fcd742096534d78bc450371775a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bce1fcd742096534d78bc450371775a">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct const_iterator pointing to past the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator pointing past last element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a69a41fdbb783e1acf736ab5b3d154472" name="a69a41fdbb783e1acf736ab5b3d154472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a41fdbb783e1acf736ab5b3d154472">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys all elements in a buffer. Does not modify capacity. </p>
<dl class="section post"><dt>Postcondition</dt><dd>All existing references, pointers and iterators are to be considered invalid.</dd></dl>
<p>Linear complexity in relation to size of the buffer. </p>

</div>
</div>
<a id="a109b2e943558eab49ca6d33ca398a838" name="a109b2e943558eab49ca6d33ca398a838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109b2e943558eab49ca6d33ca398a838">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reverse iterator pointing to the first element in reverse order (last element in normal order). </p>
<p >Constant complexity. </p><dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the first element in reverse order. </dd></dl>

</div>
</div>
<a id="a8a25432bd918d4cafbfb9e5bd47ea296" name="a8a25432bd918d4cafbfb9e5bd47ea296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a25432bd918d4cafbfb9e5bd47ea296">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order). </p>
<p >Constant complexity. </p><dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to one past the last element in reverse order. </dd></dl>

</div>
</div>
<a id="a5b078b39ae40a0c1bc0b4e60a81f67ac" name="a5b078b39ae40a0c1bc0b4e60a81f67ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b078b39ae40a0c1bc0b4e60a81f67ac">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts ringbuffer so that logical tail matches the first element in physical memory. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the first element. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet MoveInsertable, or CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>&amp;this[0] == m_data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
    <tr><td class="paramname">If</td><td>T's Move (or copy) constructor is not noexcept and throws, behaviour is undefined. Otherwise if exceptions are thrown (std::bad_alloc) this function has no effect (Strong exception guarantee). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Invalidates all existing pointers and references.</dd></dl>
<p>Linear complexity in relation to buffer size. </p>

</div>
</div>
<a id="acefe57c42e075e935c20a4da038b7df7" name="acefe57c42e075e935c20a4da038b7df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefe57c42e075e935c20a4da038b7df7">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an element in place from arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator pointing to the element where the new element will be constructed. </td></tr>
    <tr><td class="paramname">args</td><td>Argument pack containing arguments to construct value_type element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator pointing to the element constructed from args. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet EmplaceConstructible. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>returned iterator points at the element constructed from args. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if memory is allocated. Can also throw from T's constructor when constructing the element. Additionally, rotate can throw bad_alloc and if T does not provide a noexcept move semantics. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, invariants are preserved. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="aed98662b3760dac1c9ea6c98d0106068" name="aed98662b3760dac1c9ea6c98d0106068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed98662b3760dac1c9ea6c98d0106068">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in place to front from argumets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Argument pack containing arguments to construct value_type element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is EmplaceConstructible from args. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if memory is allocated. Can also throw from T's constructor when constructing the element. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, invariants are preserved. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a4a7e65ec20452b89d10f1a587fa39222" name="a4a7e65ec20452b89d10f1a587fa39222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7e65ec20452b89d10f1a587fa39222">&#9670;&#160;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in place to front from argumets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Argument pack containing arguments to construct value_type element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is EmplaceConstructible from args. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if memory is allocated. Can also throw from T's constructor when constructing the element. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, invariants are preserved. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="aa8e1113807a6554022cee5af36d3e1f0" name="aa8e1113807a6554022cee5af36d3e1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e1113807a6554022cee5af36d3e1f0">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if buffer is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if buffer is empty</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a8b3a0562418674a74bbc28eaa6ca793e" name="a8b3a0562418674a74bbc28eaa6ca793e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3a0562418674a74bbc28eaa6ca793e">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct const_iterator at end. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator pointing past last element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ab057216d2bd4ad43454758fb3eeed319" name="ab057216d2bd4ad43454758fb3eeed319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab057216d2bd4ad43454758fb3eeed319">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct iterator at end. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing past last element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a36c5e76881f854c9083ae3ea0083a3ea" name="a36c5e76881f854c9083ae3ea0083a3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c5e76881f854c9083ae3ea0083a3ea">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the specified elements from the container according to the range [first,last). Might destroy or move assign to the elements depending if last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>. If last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>, elements in [first,last) are destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element to erase. </td></tr>
    <tr><td class="paramname">last</td><td>iterator past the last element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>First and last must be valid iterators to *this. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator to the element that was immediately following the erased elements. If last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>, then <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a> is returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Possibly</td><td>throws from value_types move/copy assignment operator if last != <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>. </td></tr>
    <tr><td class="paramname">If</td><td>last != end, this function will not throw (noexcept). If the assignemnt throws, the invariants are retained. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to size of the range, and then linear in remaining elements after the erased range. </p>

</div>
</div>
<a id="ad68227da7f12db1402a6bce1cc8b834a" name="ad68227da7f12db1402a6bce1cc8b834a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68227da7f12db1402a6bce1cc8b834a">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Pointer to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must be nothrow-MoveConstructible. pos must be a valid dereferenceable iterator within the container. Otherwise behavior is undefined. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator that was immediately following the ereased element. If the erased element was last in the buffer, returns a pointer to the new last element. @except Linear Complexity. </dd></dl>

</div>
</div>
<a id="a96289837a2a156411bddba7f214cce3a" name="a96289837a2a156411bddba7f214cce3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96289837a2a156411bddba7f214cce3a">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the buffer. Behaviour is undefined for empty buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a6dee6af7622eafe9662e32f10d78b6b6" name="a6dee6af7622eafe9662e32f10d78b6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dee6af7622eafe9662e32f10d78b6b6">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the buffer. Behaviour is undefined for empty buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a527ba7169a95db0c12da90173963c2f9" name="a527ba7169a95db0c12da90173963c2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527ba7169a95db0c12da90173963c2f9">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator getter. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the allocator used by the container.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a36dccabe03199fe8f651cdeb92ec36aa" name="a36dccabe03199fe8f651cdeb92ec36aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dccabe03199fe8f651cdeb92ec36aa">&#9670;&#160;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator where the the element should be inserted </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. T must meet the requirements of CopyInsertable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that pos to the inserted element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally calls insertBase. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc, or something from T's move/copy constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, invariants are retained. (Basic Exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to amount of inserted elements. </p>

</div>
</div>
<a id="a6e9bf60beea284ff8ec7288526fbe95f" name="a6e9bf60beea284ff8ec7288526fbe95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9bf60beea284ff8ec7288526fbe95f">&#9670;&#160;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator where the the element should be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that points to the inserted element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally calls insertBase. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc, or something from T's move/copy constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, invariants are retained. (Basic Exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to amount of inserted elements. </p>

</div>
</div>
<a id="ab68cc324f43afbaef53a5f6dec8e8f79" name="ab68cc324f43afbaef53a5f6dec8e8f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68cc324f43afbaef53a5f6dec8e8f79">&#9670;&#160;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>sourceBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>sourceEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a range of elements into the buffer to a specific position. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>Type of iterator for the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the position where range will be inserted to. </td></tr>
    <tr><td class="paramname">sourceBegin</td><td>Iterator to first element of the range. </td></tr>
    <tr><td class="paramname">sourceEnd</td><td>Iterator past the last element of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator to an element in the buffer which is copy of the first element in the range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally calls insertRangeBase. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos must be a valid dereferenceable iterator within the container. Iterators must point to elements that are implicitly convertible to value_type. Otherwise behavior is undefined. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc and something from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exceptiong is thrown, invariants are retained (Basic Excpetion guarantee) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd0d87d9c657e5356151da13ab78e444" name="acd0d87d9c657e5356151da13ab78e444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0d87d9c657e5356151da13ab78e444">&#9670;&#160;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts initializer list into buffer to a specific position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator where the list will be inserted. </td></tr>
    <tr><td class="paramname">list</td><td>Initiliazer list to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos must be a valid dereferenceable iterator within the container. Otherwise behavior is undefined. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns Iterator to the first element inserted, or the element pointed by pos if the initializer list was empty. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally calls insertRangeBase. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc and something from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exceptiong is thrown, invariants are retained (Basic Excpetion guarantee) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af647fe55fa023f8b9b6e948350c09ffe" name="af647fe55fa023f8b9b6e948350c09ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af647fe55fa023f8b9b6e948350c09ffe">&#9670;&#160;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__r_buf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__r_buf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator where the the element should be inserted </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that pos to the inserted element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally calls insertBase. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc, or something from T's move/copy constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, invariants are retained. (Basic Exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to amount of inserted elements. </p>

</div>
</div>
<a id="a09435a2152f9b680154e1e51e4472787" name="a09435a2152f9b680154e1e51e4472787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09435a2152f9b680154e1e51e4472787">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the theoretical maximum size of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum size of the buffer.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="abff7619acabb085c8a582dd02c0737cb" name="abff7619acabb085c8a582dd02c0737cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff7619acabb085c8a582dd02c0737cb">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Ringbuffer to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns reference to the left hand side RungBuffer after swap. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*this == other.</dd></dl>
<p>Constant complexity. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or something from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, this function has no effect (Strong Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size. </p>

</div>
</div>
<a id="a3e98268d8b4fc82a786f32c000b78018" name="a3e98268d8b4fc82a786f32c000b78018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e98268d8b4fc82a786f32c000b78018">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Rvalue ref to other buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is MoveConstructible. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*this has values other had before the assignment. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the buffer to move from. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>value_type is not MoveConstructible, and value_type provides a throwing CopyConstructor is used this function has undefined behaviour.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ac8b1641644c85ff869a2458ee6e2912f" name="ac8b1641644c85ff869a2458ee6e2912f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b1641644c85ff869a2458ee6e2912f">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list assign operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to assign to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the buffer. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T is CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All existing iterators are invalidated. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally calls <a class="el" href="classring__buffer.html#a2ff5b379f041a4f7ff1cfc8a2a8f69c5" title="Replaces the elements in the buffer with copy of [sourceBegin, sourceEnd)">assign()</a>, which destroys all elements before CopyInserting from initializer list.</dd></dl>
<p>Linear complexity in relation to amount of existing elements and size of initializer list. </p>

</div>
</div>
<a id="a3bbae1471c094bf84d8f1950a525e513" name="a3bbae1471c094bf84d8f1950a525e513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbae1471c094bf84d8f1950a525e513">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>logicalIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalIndex</td><td>Index of the element used to access n:th element of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity </p><dl class="section note"><dt>Note</dt><dd>The operator acts as interface that hides the physical memory layout from the user. Logical index neeeds to be added to internal tail index to get actual element address. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference the the element ad logicalIndex. </dd></dl>

</div>
</div>
<a id="a7c14c9afba67aad502b36653d1bbc2ca" name="a7c14c9afba67aad502b36653d1bbc2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c14c9afba67aad502b36653d1bbc2ca">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>logicalIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalIndex</td><td>Index of the element. If LogicalIndex &gt;= <a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5" title="Gets the size of the container.">size()</a>, this function has undefined behavriour.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p><dl class="section note"><dt>Note</dt><dd>The operator acts as interface that hides the physical memory layout from the user. Logical index neeeds to be added to internal tail index to get actual element address. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the element. </dd></dl>

</div>
</div>
<a id="ad1c703f9814872877775d2a5c2fef243" name="ad1c703f9814872877775d2a5c2fef243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c703f9814872877775d2a5c2fef243">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element from the logical back of the buffer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Buffers size &gt; 0, otherwise behaviour is undefined. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All pointers and references are invalidated. Iterators persist except <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a> - 1 iterator is invalidated (it becomes new past-the-last iterator).</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="aef28bc848394b3bc6a1dea129dbb412f" name="aef28bc848394b3bc6a1dea129dbb412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef28bc848394b3bc6a1dea129dbb412f">&#9670;&#160;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first element in the buffer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Buffers size &gt; 0, otherwise behaviour is undefined. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All iterators, pointers and references are invalidated.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a3de0c8df71d288b2948d618bdd930250" name="a3de0c8df71d288b2948d618bdd930250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de0c8df71d288b2948d618bdd930250">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element in the back of the buffer. If buffer would get full after the operation, allocates more memory. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory for allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value of type T to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Allocates memory before the insertion if the buffer would be full after the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
    <tr><td class="paramname">If</td><td>the copy constructor of value_type throws, behaviour is undefined. Otherwise in case of exception this function retains invariants (Basic Exception Guarantee). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type needs to satisfy CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If more memory is allocated all pointers, iterators and references are invalidated.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a7d8ed70b4ef81563f9e8d349f256d84c" name="a7d8ed70b4ef81563f9e8d349f256d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8ed70b4ef81563f9e8d349f256d84c">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element in the back of the buffer by move if move constructor is provided for value_type. If buffer would get full after the operation, allocates more memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Rvalue reference to the value to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Allocates memory before the insertion if the buffer would be full after the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if more memory is allocated. </td></tr>
    <tr><td class="paramname">If</td><td>the move/copy constructor of value_type throws, behaviour is undefined. Otherwise in case of any exception this function retains invariants (Basic Exception Guarantee). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type needs to satisfy MoveInsertable or CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If more memory is allocated all pointers, iterators and references are invalidated.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a4bed0fe915650f882f772d022f89bc0b" name="a4bed0fe915650f882f772d022f89bc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bed0fe915650f882f772d022f89bc0b">&#9670;&#160;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element in the back of the buffer. If buffer would get full after the operation, allocates more memory. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory for allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Element to insert. Needs to be CopyConstructible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All iterators are invalidated. If allocation happens, all pointers and references are invalidated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the move/copy constructor of value_type throws, behaviour is undefined. Otherwise in case of exception this function retains invariants (Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ab2d27891d77e19442f1d8acaa26b11ee" name="ab2d27891d77e19442f1d8acaa26b11ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d27891d77e19442f1d8acaa26b11ee">&#9670;&#160;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element in the back of the buffer by move if move constructor is provided by value_type. If buffer would get full after the operation, allocates more memory. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if there is not enough memory for allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Rvalue reference to the element to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type needs to satisfy MoveInsertable or CopyInsertable. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>All iterators are invalidated. If allocation happens, all pointers and references are invalidated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the move/copy constructor of value_type throws, behaviour is undefined. Otherwise in case of any exception this function retains invariants (Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ab456f054b5903b00e9b23ecf0b93675d" name="ab456f054b5903b00e9b23ecf0b93675d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab456f054b5903b00e9b23ecf0b93675d">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reverse iterator pointing to the first element in reverse order (last element in normal order). </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to first element in reverse order.</dd></dl>
<p>Constant complexity. Iterator is invalid if the buffer is empty (dereferencing points to uninitialized memory.). </p>

</div>
</div>
<a id="aa243a80e8756739ce4b64f73e9a4338e" name="aa243a80e8756739ce4b64f73e9a4338e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa243a80e8756739ce4b64f73e9a4338e">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reverse iterator pointing to the first element in reverse order (last element in normal order). </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the first element in reverse order.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a81ee796bf66742e0d25716ce4c9d6f5d" name="a81ee796bf66742e0d25716ce4c9d6f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ee796bf66742e0d25716ce4c9d6f5d">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order). </p>
<p >Constant complexity. </p><dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to one past the last element in reverse order. </dd></dl>

</div>
</div>
<a id="ae9dcf3f2bfc1c9be3d18ab2d25eebd48" name="ae9dcf3f2bfc1c9be3d18ab2d25eebd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dcf3f2bfc1c9be3d18ab2d25eebd48">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order). </p>
<p >Constant complexity. </p><dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to one past the last element in reverse order. </dd></dl>

</div>
</div>
<a id="a8f6fd7a2d343de27c99761c6029f6d28" name="a8f6fd7a2d343de27c99761c6029f6d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6fd7a2d343de27c99761c6029f6d28">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableShrink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory and copies the existing buffer to the new memory location. Can be used to increase or decrease capacity. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>std::bad_alloc if there is not enough memory for allocation. Throws std::bad_array_new_lenght if std::numeric_limits&lt;std::size_t&gt;::max() / sizeof(T) &lt; newsize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>Amount of memory to allocate. If newCapacity is less than or equal to m_capacity, function does nothing. </td></tr>
    <tr><td class="paramname">enableShrink</td><td>True to enable reserve to reduce the capacity, to a minimum of <a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5" title="Gets the size of the container.">size()</a> +2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
    <tr><td class="paramname">If</td><td>T's move (or copy if T has no move) constructor throws, behaviour is undefined. Otherwise Stong Exception Guarantee. @notes All references, pointers and iterators are invalidated. If memory is allocated, the memory layout is rotated so that first element matches the beginning of physical memory.</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to size of the buffer. </p>

</div>
</div>
<a id="a4404cf478938dc61b93a963581bd2f3a" name="a4404cf478938dc61b93a963581bd2f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4404cf478938dc61b93a963581bd2f3a">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases unused allocated memory. </p>
<dl class="section pre"><dt>Precondition</dt><dd>T must satisfy MoveConstructible or CopyConstructible. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>m_capacity == <a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5" title="Gets the size of the container.">size()</a> + 2. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reduces capacity by allocating a smaller memory area and moving the elements. Shrinking the buffer invalidates all pointers, iterators and references. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if memory allocation fails. </td></tr>
    <tr><td class="paramname">If</td><td>T's move (or copy) constructor can and does throw, behaviour is undefined. If any other exception is thrown (bad_alloc) this function has no effect (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to size of the buffer. </p>

</div>
</div>
<a id="aca0782fc0b1264ff01c5ffbe199423a5" name="aca0782fc0b1264ff01c5ffbe199423a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0782fc0b1264ff01c5ffbe199423a5">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of buffer.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="aa53ef9bfdabd3a5e613413b27c66de61" name="aa53ef9bfdabd3a5e613413b27c66de61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53ef9bfdabd3a5e613413b27c66de61">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Member swap implementation. Swaps RingBuffers member to member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Reference to a <a class="el" href="classring__buffer.html" title="Dynamic Ringbuffer is a dynamically growing std::container with support for queue,...">ring_buffer</a> to swap with.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a15bc4c9d1486b1fcd9b8c5f7956b3d4c" name="a15bc4c9d1486b1fcd9b8c5f7956b3d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bc4c9d1486b1fcd9b8c5f7956b3d4c">&#9670;&#160;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Friend swap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Swap candidate. </td></tr>
    <tr><td class="paramname">b</td><td>Swap candidate.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="ring__buffer_8hpp_source.html">ring_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
