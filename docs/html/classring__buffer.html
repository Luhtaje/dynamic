<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DynamicRingBuffer: ring_buffer&lt; T, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamicRingBuffer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classring__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ring_buffer&lt; T, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Dynamic Ringbuffer is a dynamically growing circular AllocatorAware std::container with support for queue, stack and priority queue adaptor functionality.  
 <a href="classring__buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ring__buffer_8hpp_source.html">ring_buffer.hpp</a>&gt;</code></p>

<p>Inherits ring_buffer_base&lt; T, Allocator &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">_rBuf_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom iterator class.  <a href="classring__buffer_1_1__rBuf__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">_rBuf_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom iterator class.  <a href="classring__buffer_1_1__rBuf__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3941064be54c41ce0c6de961f256a923"><td class="memItemLeft" align="right" valign="top"><a id="a3941064be54c41ce0c6de961f256a923"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>base</b> = typename <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::ring_buffer_base</td></tr>
<tr class="separator:a3941064be54c41ce0c6de961f256a923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bb7fcf18efac4fd9392b0d1e7936e2"><td class="memItemLeft" align="right" valign="top"><a id="a86bb7fcf18efac4fd9392b0d1e7936e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a86bb7fcf18efac4fd9392b0d1e7936e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad513971955235a51282d9c51f6734fe7"><td class="memItemLeft" align="right" valign="top"><a id="ad513971955235a51282d9c51f6734fe7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = T &amp;</td></tr>
<tr class="separator:ad513971955235a51282d9c51f6734fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca2866bc954c6d9feed98e06b480244"><td class="memItemLeft" align="right" valign="top"><a id="adca2866bc954c6d9feed98e06b480244"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const T &amp;</td></tr>
<tr class="separator:adca2866bc954c6d9feed98e06b480244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdf728b5383f55939236b958dbdc6e9"><td class="memItemLeft" align="right" valign="top"><a id="a6cdf728b5383f55939236b958dbdc6e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = T *</td></tr>
<tr class="separator:a6cdf728b5383f55939236b958dbdc6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3d9241f27d43d0bb84fec76da2409"><td class="memItemLeft" align="right" valign="top"><a id="ae7a3d9241f27d43d0bb84fec76da2409"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const T *</td></tr>
<tr class="separator:ae7a3d9241f27d43d0bb84fec76da2409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea16f16223deef2aa829de2831dbdc9"><td class="memItemLeft" align="right" valign="top"><a id="abea16f16223deef2aa829de2831dbdc9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="separator:abea16f16223deef2aa829de2831dbdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5201496780447d1b83c9648e07752af"><td class="memItemLeft" align="right" valign="top"><a id="aa5201496780447d1b83c9648e07752af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classring__buffer_1_1__rBuf__iterator.html">_rBuf_iterator</a>&lt; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:aa5201496780447d1b83c9648e07752af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a1ec5234f371d755ec75bfd9adafea"><td class="memItemLeft" align="right" valign="top"><a id="af9a1ec5234f371d755ec75bfd9adafea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">_rBuf_const_iterator</a>&lt; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:af9a1ec5234f371d755ec75bfd9adafea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4c92d2b89348303d05286347c7f66e"><td class="memItemLeft" align="right" valign="top"><a id="a1b4c92d2b89348303d05286347c7f66e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a1b4c92d2b89348303d05286347c7f66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9412feef29dc7e6e73b380578691a3"><td class="memItemLeft" align="right" valign="top"><a id="afb9412feef29dc7e6e73b380578691a3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt; <a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:afb9412feef29dc7e6e73b380578691a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f9101235ae01592332386c047e17d0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3f9101235ae01592332386c047e17d0d">ring_buffer</a> ()</td></tr>
<tr class="memdesc:a3f9101235ae01592332386c047e17d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classring__buffer.html#a3f9101235ae01592332386c047e17d0d">More...</a><br /></td></tr>
<tr class="separator:a3f9101235ae01592332386c047e17d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4995dd6a70c19f3fb90e17a3c0d2daa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4995dd6a70c19f3fb90e17a3c0d2daa4">ring_buffer</a> (const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:a4995dd6a70c19f3fb90e17a3c0d2daa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with a custom allocator.  <a href="classring__buffer.html#a4995dd6a70c19f3fb90e17a3c0d2daa4">More...</a><br /></td></tr>
<tr class="separator:a4995dd6a70c19f3fb90e17a3c0d2daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2449de34e9c4a70e81c5c76a1a75e71f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a2449de34e9c4a70e81c5c76a1a75e71f">ring_buffer</a> (size_type count, const_reference val, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a2449de34e9c4a70e81c5c76a1a75e71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the buffer to a given size with given values and optionally a custom allocator.  <a href="classring__buffer.html#a2449de34e9c4a70e81c5c76a1a75e71f">More...</a><br /></td></tr>
<tr class="separator:a2449de34e9c4a70e81c5c76a1a75e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2648ee9dbe34781862260df46ac0d1e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a2648ee9dbe34781862260df46ac0d1e5">ring_buffer</a> (size_type count, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a2648ee9dbe34781862260df46ac0d1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom constructor. Initializes a buffer with count amount of default constructed value_type elements.  <a href="classring__buffer.html#a2648ee9dbe34781862260df46ac0d1e5">More...</a><br /></td></tr>
<tr class="separator:a2648ee9dbe34781862260df46ac0d1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d43ed1b6357105e41d7811d5da6638"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename  = std::enable_if_t&lt;std::is_convertible&lt;typename std::iterator_traits&lt;InputIt&gt;::value_type,value_type&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a34d43ed1b6357105e41d7811d5da6638"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a34d43ed1b6357105e41d7811d5da6638">ring_buffer</a> (InputIt beginIt, InputIt endIt, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a34d43ed1b6357105e41d7811d5da6638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the buffer from range [begin,end).  <a href="classring__buffer.html#a34d43ed1b6357105e41d7811d5da6638">More...</a><br /></td></tr>
<tr class="separator:a34d43ed1b6357105e41d7811d5da6638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37abccd052de210c36f6f397cd841a93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a37abccd052de210c36f6f397cd841a93">ring_buffer</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a37abccd052de210c36f6f397cd841a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list contructor.  <a href="classring__buffer.html#a37abccd052de210c36f6f397cd841a93">More...</a><br /></td></tr>
<tr class="separator:a37abccd052de210c36f6f397cd841a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8925b041c137104b31c975169dd05b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ad8925b041c137104b31c975169dd05b0">ring_buffer</a> (const <a class="el" href="classring__buffer.html">ring_buffer</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad8925b041c137104b31c975169dd05b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classring__buffer.html#ad8925b041c137104b31c975169dd05b0">More...</a><br /></td></tr>
<tr class="separator:ad8925b041c137104b31c975169dd05b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e0d47fef23cc18aaa59b0447799b18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#af1e0d47fef23cc18aaa59b0447799b18">ring_buffer</a> (const <a class="el" href="classring__buffer.html">ring_buffer</a> &amp;rhs, const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:af1e0d47fef23cc18aaa59b0447799b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with custom allocator.  <a href="classring__buffer.html#af1e0d47fef23cc18aaa59b0447799b18">More...</a><br /></td></tr>
<tr class="separator:af1e0d47fef23cc18aaa59b0447799b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232425cc3a36aeb1a844956fd93623f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a232425cc3a36aeb1a844956fd93623f0">ring_buffer</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a232425cc3a36aeb1a844956fd93623f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classring__buffer.html#a232425cc3a36aeb1a844956fd93623f0">More...</a><br /></td></tr>
<tr class="separator:a232425cc3a36aeb1a844956fd93623f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bcb469aba7cabbc293495eea355e6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ac2bcb469aba7cabbc293495eea355e6d">ring_buffer</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&amp;other, const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:ac2bcb469aba7cabbc293495eea355e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with different allocator.  <a href="classring__buffer.html#ac2bcb469aba7cabbc293495eea355e6d">More...</a><br /></td></tr>
<tr class="separator:ac2bcb469aba7cabbc293495eea355e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba67a9f961ab436428b0710cd1af773"><td class="memItemLeft" align="right" valign="top"><a id="adba67a9f961ab436428b0710cd1af773"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#adba67a9f961ab436428b0710cd1af773">~ring_buffer</a> ()</td></tr>
<tr class="memdesc:adba67a9f961ab436428b0710cd1af773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adba67a9f961ab436428b0710cd1af773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9bf60beea284ff8ec7288526fbe95f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a6e9bf60beea284ff8ec7288526fbe95f">insert</a> (<a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> pos, const value_type &amp;value)</td></tr>
<tr class="memdesc:a6e9bf60beea284ff8ec7288526fbe95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element to the buffer.  <a href="classring__buffer.html#a6e9bf60beea284ff8ec7288526fbe95f">More...</a><br /></td></tr>
<tr class="separator:a6e9bf60beea284ff8ec7288526fbe95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af647fe55fa023f8b9b6e948350c09ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#af647fe55fa023f8b9b6e948350c09ffe">insert</a> (<a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> pos, value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:af647fe55fa023f8b9b6e948350c09ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element to the buffer.  <a href="classring__buffer.html#af647fe55fa023f8b9b6e948350c09ffe">More...</a><br /></td></tr>
<tr class="separator:af647fe55fa023f8b9b6e948350c09ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d9f8150e7762f6661154d0e37dc6ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ae2d9f8150e7762f6661154d0e37dc6ca">insert</a> (<a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> pos, const size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:ae2d9f8150e7762f6661154d0e37dc6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element to the buffer.  <a href="classring__buffer.html#ae2d9f8150e7762f6661154d0e37dc6ca">More...</a><br /></td></tr>
<tr class="separator:ae2d9f8150e7762f6661154d0e37dc6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68cc324f43afbaef53a5f6dec8e8f79"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:ab68cc324f43afbaef53a5f6dec8e8f79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ab68cc324f43afbaef53a5f6dec8e8f79">insert</a> (<a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> pos, InputIt sourceBegin, InputIt sourceEnd)</td></tr>
<tr class="memdesc:ab68cc324f43afbaef53a5f6dec8e8f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a range of elements into the buffer to a specific position.  <a href="classring__buffer.html#ab68cc324f43afbaef53a5f6dec8e8f79">More...</a><br /></td></tr>
<tr class="separator:ab68cc324f43afbaef53a5f6dec8e8f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0d87d9c657e5356151da13ab78e444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#acd0d87d9c657e5356151da13ab78e444">insert</a> (<a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> pos, std::initializer_list&lt; T &gt; list)</td></tr>
<tr class="memdesc:acd0d87d9c657e5356151da13ab78e444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts initializer list into buffer to a specific position.  <a href="classring__buffer.html#acd0d87d9c657e5356151da13ab78e444">More...</a><br /></td></tr>
<tr class="separator:acd0d87d9c657e5356151da13ab78e444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefe57c42e075e935c20a4da038b7df7"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:acefe57c42e075e935c20a4da038b7df7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#acefe57c42e075e935c20a4da038b7df7">emplace</a> (<a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acefe57c42e075e935c20a4da038b7df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element in place from arguments.  <a href="classring__buffer.html#acefe57c42e075e935c20a4da038b7df7">More...</a><br /></td></tr>
<tr class="separator:acefe57c42e075e935c20a4da038b7df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e65ec20452b89d10f1a587fa39222"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4a7e65ec20452b89d10f1a587fa39222"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4a7e65ec20452b89d10f1a587fa39222">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4a7e65ec20452b89d10f1a587fa39222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in place to front from argumets.  <a href="classring__buffer.html#a4a7e65ec20452b89d10f1a587fa39222">More...</a><br /></td></tr>
<tr class="separator:a4a7e65ec20452b89d10f1a587fa39222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed98662b3760dac1c9ea6c98d0106068"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aed98662b3760dac1c9ea6c98d0106068"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aed98662b3760dac1c9ea6c98d0106068">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aed98662b3760dac1c9ea6c98d0106068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in place to front from argumets.  <a href="classring__buffer.html#aed98662b3760dac1c9ea6c98d0106068">More...</a><br /></td></tr>
<tr class="separator:aed98662b3760dac1c9ea6c98d0106068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68227da7f12db1402a6bce1cc8b834a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ad68227da7f12db1402a6bce1cc8b834a">erase</a> (<a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ad68227da7f12db1402a6bce1cc8b834a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element at a given position.  <a href="classring__buffer.html#ad68227da7f12db1402a6bce1cc8b834a">More...</a><br /></td></tr>
<tr class="separator:ad68227da7f12db1402a6bce1cc8b834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c5e76881f854c9083ae3ea0083a3ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a36c5e76881f854c9083ae3ea0083a3ea">erase</a> (<a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> first, <a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:a36c5e76881f854c9083ae3ea0083a3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the specified elements from the container according to the range [first,last). Might destroy or move assign to the elements depending if last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>. If last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>, elements in [first,last) are destroyed.  <a href="classring__buffer.html#a36c5e76881f854c9083ae3ea0083a3ea">More...</a><br /></td></tr>
<tr class="separator:a36c5e76881f854c9083ae3ea0083a3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a41fdbb783e1acf736ab5b3d154472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a69a41fdbb783e1acf736ab5b3d154472">clear</a> () noexcept</td></tr>
<tr class="memdesc:a69a41fdbb783e1acf736ab5b3d154472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all elements in a buffer. Does not modify capacity.  <a href="classring__buffer.html#a69a41fdbb783e1acf736ab5b3d154472">More...</a><br /></td></tr>
<tr class="separator:a69a41fdbb783e1acf736ab5b3d154472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff5b379f041a4f7ff1cfc8a2a8f69c5"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a2ff5b379f041a4f7ff1cfc8a2a8f69c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a2ff5b379f041a4f7ff1cfc8a2a8f69c5">assign</a> (InputIt sourceBegin, InputIt sourceEnd)</td></tr>
<tr class="memdesc:a2ff5b379f041a4f7ff1cfc8a2a8f69c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the elements in the buffer with copy of [sourceBegin, sourceEnd)  <a href="classring__buffer.html#a2ff5b379f041a4f7ff1cfc8a2a8f69c5">More...</a><br /></td></tr>
<tr class="separator:a2ff5b379f041a4f7ff1cfc8a2a8f69c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5e7138c98dc161fad55891ec10a35b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#acf5e7138c98dc161fad55891ec10a35b">assign</a> (std::initializer_list&lt; T &gt; list)</td></tr>
<tr class="memdesc:acf5e7138c98dc161fad55891ec10a35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the elements in the buffer with copy of the initializer list.  <a href="classring__buffer.html#acf5e7138c98dc161fad55891ec10a35b">More...</a><br /></td></tr>
<tr class="separator:acf5e7138c98dc161fad55891ec10a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747ef0e5bac6c9ee2eb4c3e7b728588"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ae747ef0e5bac6c9ee2eb4c3e7b728588">assign</a> (const size_type amount, const value_type &amp;value)</td></tr>
<tr class="memdesc:ae747ef0e5bac6c9ee2eb4c3e7b728588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the elements in the buffer with given value.  <a href="classring__buffer.html#ae747ef0e5bac6c9ee2eb4c3e7b728588">More...</a><br /></td></tr>
<tr class="separator:ae747ef0e5bac6c9ee2eb4c3e7b728588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75342dd634240adde461810a0cee4504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a75342dd634240adde461810a0cee4504">operator=</a> (const <a class="el" href="classring__buffer.html">ring_buffer</a> &amp;other)</td></tr>
<tr class="memdesc:a75342dd634240adde461810a0cee4504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classring__buffer.html#a75342dd634240adde461810a0cee4504">More...</a><br /></td></tr>
<tr class="separator:a75342dd634240adde461810a0cee4504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124ac4c5e7a58fde1379ffb40dac39ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a124ac4c5e7a58fde1379ffb40dac39ef">operator=</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a124ac4c5e7a58fde1379ffb40dac39ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classring__buffer.html#a124ac4c5e7a58fde1379ffb40dac39ef">More...</a><br /></td></tr>
<tr class="separator:a124ac4c5e7a58fde1379ffb40dac39ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89969f6013137b1cda7489ae422759f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer.html">ring_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a89969f6013137b1cda7489ae422759f1">operator=</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a89969f6013137b1cda7489ae422759f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list assign operator.  <a href="classring__buffer.html#a89969f6013137b1cda7489ae422759f1">More...</a><br /></td></tr>
<tr class="separator:a89969f6013137b1cda7489ae422759f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c14c9afba67aad502b36653d1bbc2ca"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a7c14c9afba67aad502b36653d1bbc2ca">operator[]</a> (const size_type logicalIndex) noexcept</td></tr>
<tr class="memdesc:a7c14c9afba67aad502b36653d1bbc2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index operator.  <a href="classring__buffer.html#a7c14c9afba67aad502b36653d1bbc2ca">More...</a><br /></td></tr>
<tr class="separator:a7c14c9afba67aad502b36653d1bbc2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbae1471c094bf84d8f1950a525e513"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3bbae1471c094bf84d8f1950a525e513">operator[]</a> (const size_type logicalIndex) const noexcept</td></tr>
<tr class="memdesc:a3bbae1471c094bf84d8f1950a525e513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index operator.  <a href="classring__buffer.html#a3bbae1471c094bf84d8f1950a525e513">More...</a><br /></td></tr>
<tr class="separator:a3bbae1471c094bf84d8f1950a525e513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb085b3f95fdedb1906f4fb9f22c8f"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a15eb085b3f95fdedb1906f4fb9f22c8f">at</a> (size_type logicalIndex)</td></tr>
<tr class="memdesc:a15eb085b3f95fdedb1906f4fb9f22c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific element of the buffer with bounds checking.  <a href="classring__buffer.html#a15eb085b3f95fdedb1906f4fb9f22c8f">More...</a><br /></td></tr>
<tr class="separator:a15eb085b3f95fdedb1906f4fb9f22c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988f02984769a27167341843f36060a4"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a988f02984769a27167341843f36060a4">at</a> (size_type logicalIndex) const</td></tr>
<tr class="memdesc:a988f02984769a27167341843f36060a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific element of the buffer.  <a href="classring__buffer.html#a988f02984769a27167341843f36060a4">More...</a><br /></td></tr>
<tr class="separator:a988f02984769a27167341843f36060a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53ef9bfdabd3a5e613413b27c66de61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aa53ef9bfdabd3a5e613413b27c66de61">swap</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aa53ef9bfdabd3a5e613413b27c66de61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member swap implementation. Swaps RingBuffers member to member.  <a href="classring__buffer.html#aa53ef9bfdabd3a5e613413b27c66de61">More...</a><br /></td></tr>
<tr class="separator:aa53ef9bfdabd3a5e613413b27c66de61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b078b39ae40a0c1bc0b4e60a81f67ac"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a5b078b39ae40a0c1bc0b4e60a81f67ac">data</a> ()</td></tr>
<tr class="memdesc:a5b078b39ae40a0c1bc0b4e60a81f67ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts ringbuffer so that logical tail matches the first element in physical memory.  <a href="classring__buffer.html#a5b078b39ae40a0c1bc0b4e60a81f67ac">More...</a><br /></td></tr>
<tr class="separator:a5b078b39ae40a0c1bc0b4e60a81f67ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0782fc0b1264ff01c5ffbe199423a5"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5">size</a> () const noexcept</td></tr>
<tr class="memdesc:aca0782fc0b1264ff01c5ffbe199423a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the container.  <a href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5">More...</a><br /></td></tr>
<tr class="separator:aca0782fc0b1264ff01c5ffbe199423a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09435a2152f9b680154e1e51e4472787"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a09435a2152f9b680154e1e51e4472787">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a09435a2152f9b680154e1e51e4472787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the theoretical maximum size of the container.  <a href="classring__buffer.html#a09435a2152f9b680154e1e51e4472787">More...</a><br /></td></tr>
<tr class="separator:a09435a2152f9b680154e1e51e4472787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb98388fa6ae8a7a86e968d95534c8fd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aeb98388fa6ae8a7a86e968d95534c8fd">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:aeb98388fa6ae8a7a86e968d95534c8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity getter.  <a href="classring__buffer.html#aeb98388fa6ae8a7a86e968d95534c8fd">More...</a><br /></td></tr>
<tr class="separator:aeb98388fa6ae8a7a86e968d95534c8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ba7169a95db0c12da90173963c2f9"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a527ba7169a95db0c12da90173963c2f9">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a527ba7169a95db0c12da90173963c2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator getter.  <a href="classring__buffer.html#a527ba7169a95db0c12da90173963c2f9">More...</a><br /></td></tr>
<tr class="separator:a527ba7169a95db0c12da90173963c2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e1113807a6554022cee5af36d3e1f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aa8e1113807a6554022cee5af36d3e1f0">empty</a> () const noexcept</td></tr>
<tr class="memdesc:aa8e1113807a6554022cee5af36d3e1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if buffer is empty.  <a href="classring__buffer.html#aa8e1113807a6554022cee5af36d3e1f0">More...</a><br /></td></tr>
<tr class="separator:aa8e1113807a6554022cee5af36d3e1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6fd7a2d343de27c99761c6029f6d28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a8f6fd7a2d343de27c99761c6029f6d28">reserve</a> (size_type newCapacity, bool enableShrink=false)</td></tr>
<tr class="memdesc:a8f6fd7a2d343de27c99761c6029f6d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory and copies the existing buffer to the new memory location. Can be used to increase or decrease capacity.  <a href="classring__buffer.html#a8f6fd7a2d343de27c99761c6029f6d28">More...</a><br /></td></tr>
<tr class="separator:a8f6fd7a2d343de27c99761c6029f6d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bed0fe915650f882f772d022f89bc0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4bed0fe915650f882f772d022f89bc0b">push_front</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:a4bed0fe915650f882f772d022f89bc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the back of the buffer.  <a href="classring__buffer.html#a4bed0fe915650f882f772d022f89bc0b">More...</a><br /></td></tr>
<tr class="separator:a4bed0fe915650f882f772d022f89bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d27891d77e19442f1d8acaa26b11ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ab2d27891d77e19442f1d8acaa26b11ee">push_front</a> (value_type &amp;&amp;val)</td></tr>
<tr class="memdesc:ab2d27891d77e19442f1d8acaa26b11ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the back of the buffer by move if move constructor is provided by value_type.  <a href="classring__buffer.html#ab2d27891d77e19442f1d8acaa26b11ee">More...</a><br /></td></tr>
<tr class="separator:ab2d27891d77e19442f1d8acaa26b11ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de0c8df71d288b2948d618bdd930250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3de0c8df71d288b2948d618bdd930250">push_back</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:a3de0c8df71d288b2948d618bdd930250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the back of the buffer.  <a href="classring__buffer.html#a3de0c8df71d288b2948d618bdd930250">More...</a><br /></td></tr>
<tr class="separator:a3de0c8df71d288b2948d618bdd930250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ed70b4ef81563f9e8d349f256d84c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a7d8ed70b4ef81563f9e8d349f256d84c">push_back</a> (value_type &amp;&amp;val)</td></tr>
<tr class="memdesc:a7d8ed70b4ef81563f9e8d349f256d84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the back of the buffer by move if move constructor is provided for value_type.  <a href="classring__buffer.html#a7d8ed70b4ef81563f9e8d349f256d84c">More...</a><br /></td></tr>
<tr class="separator:a7d8ed70b4ef81563f9e8d349f256d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef28bc848394b3bc6a1dea129dbb412f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aef28bc848394b3bc6a1dea129dbb412f">pop_front</a> () noexcept</td></tr>
<tr class="memdesc:aef28bc848394b3bc6a1dea129dbb412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first element in the buffer.  <a href="classring__buffer.html#aef28bc848394b3bc6a1dea129dbb412f">More...</a><br /></td></tr>
<tr class="separator:aef28bc848394b3bc6a1dea129dbb412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c703f9814872877775d2a5c2fef243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ad1c703f9814872877775d2a5c2fef243">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:ad1c703f9814872877775d2a5c2fef243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element from the logical back of the buffer.  <a href="classring__buffer.html#ad1c703f9814872877775d2a5c2fef243">More...</a><br /></td></tr>
<tr class="separator:ad1c703f9814872877775d2a5c2fef243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4404cf478938dc61b93a963581bd2f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4404cf478938dc61b93a963581bd2f3a">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a4404cf478938dc61b93a963581bd2f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases unused allocated memory.  <a href="classring__buffer.html#a4404cf478938dc61b93a963581bd2f3a">More...</a><br /></td></tr>
<tr class="separator:a4404cf478938dc61b93a963581bd2f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dee6af7622eafe9662e32f10d78b6b6"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a6dee6af7622eafe9662e32f10d78b6b6">front</a> () noexcept</td></tr>
<tr class="memdesc:a6dee6af7622eafe9662e32f10d78b6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the buffer. Behaviour is undefined for empty buffer.  <a href="classring__buffer.html#a6dee6af7622eafe9662e32f10d78b6b6">More...</a><br /></td></tr>
<tr class="separator:a6dee6af7622eafe9662e32f10d78b6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96289837a2a156411bddba7f214cce3a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a96289837a2a156411bddba7f214cce3a">front</a> () const noexcept</td></tr>
<tr class="memdesc:a96289837a2a156411bddba7f214cce3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the buffer. Behaviour is undefined for empty buffer.  <a href="classring__buffer.html#a96289837a2a156411bddba7f214cce3a">More...</a><br /></td></tr>
<tr class="separator:a96289837a2a156411bddba7f214cce3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ca98342bbe89dd9aba19838cb7b407"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ae7ca98342bbe89dd9aba19838cb7b407">back</a> () noexcept</td></tr>
<tr class="memdesc:ae7ca98342bbe89dd9aba19838cb7b407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the buffer. Behaviour is undefined for empty buffer.  <a href="classring__buffer.html#ae7ca98342bbe89dd9aba19838cb7b407">More...</a><br /></td></tr>
<tr class="separator:ae7ca98342bbe89dd9aba19838cb7b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0661379f8b19f49d5e5d026455be9617"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a0661379f8b19f49d5e5d026455be9617">back</a> () const noexcept</td></tr>
<tr class="memdesc:a0661379f8b19f49d5e5d026455be9617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const-reference to the last element in the buffer. Behaviour is undefined for empty buffer.  <a href="classring__buffer.html#a0661379f8b19f49d5e5d026455be9617">More...</a><br /></td></tr>
<tr class="separator:a0661379f8b19f49d5e5d026455be9617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2abcc16c769e390ed5fc16b320cce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a4a2abcc16c769e390ed5fc16b320cce7">begin</a> () noexcept</td></tr>
<tr class="memdesc:a4a2abcc16c769e390ed5fc16b320cce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct iterator at begin.  <a href="classring__buffer.html#a4a2abcc16c769e390ed5fc16b320cce7">More...</a><br /></td></tr>
<tr class="separator:a4a2abcc16c769e390ed5fc16b320cce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8347b456303e02b7a9ee23312859a621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a8347b456303e02b7a9ee23312859a621">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a8347b456303e02b7a9ee23312859a621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct const_iterator at begin.  <a href="classring__buffer.html#a8347b456303e02b7a9ee23312859a621">More...</a><br /></td></tr>
<tr class="separator:a8347b456303e02b7a9ee23312859a621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab057216d2bd4ad43454758fb3eeed319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319">end</a> () noexcept</td></tr>
<tr class="memdesc:ab057216d2bd4ad43454758fb3eeed319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct iterator at end.  <a href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319">More...</a><br /></td></tr>
<tr class="separator:ab057216d2bd4ad43454758fb3eeed319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3a0562418674a74bbc28eaa6ca793e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a8b3a0562418674a74bbc28eaa6ca793e">end</a> () const noexcept</td></tr>
<tr class="memdesc:a8b3a0562418674a74bbc28eaa6ca793e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct const_iterator at end.  <a href="classring__buffer.html#a8b3a0562418674a74bbc28eaa6ca793e">More...</a><br /></td></tr>
<tr class="separator:a8b3a0562418674a74bbc28eaa6ca793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9494413971913e7702426e7fe8968c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a9494413971913e7702426e7fe8968c6a">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a9494413971913e7702426e7fe8968c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct const_iterator at begin.  <a href="classring__buffer.html#a9494413971913e7702426e7fe8968c6a">More...</a><br /></td></tr>
<tr class="separator:a9494413971913e7702426e7fe8968c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bce1fcd742096534d78bc450371775a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a3bce1fcd742096534d78bc450371775a">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a3bce1fcd742096534d78bc450371775a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct const_iterator pointing to past the last element.  <a href="classring__buffer.html#a3bce1fcd742096534d78bc450371775a">More...</a><br /></td></tr>
<tr class="separator:a3bce1fcd742096534d78bc450371775a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab456f054b5903b00e9b23ecf0b93675d"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ab456f054b5903b00e9b23ecf0b93675d">rbegin</a> ()</td></tr>
<tr class="memdesc:ab456f054b5903b00e9b23ecf0b93675d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reverse iterator pointing to the first element in reverse order (last element in normal order).  <a href="classring__buffer.html#ab456f054b5903b00e9b23ecf0b93675d">More...</a><br /></td></tr>
<tr class="separator:ab456f054b5903b00e9b23ecf0b93675d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa243a80e8756739ce4b64f73e9a4338e"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#aa243a80e8756739ce4b64f73e9a4338e">rbegin</a> () const</td></tr>
<tr class="memdesc:aa243a80e8756739ce4b64f73e9a4338e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reverse iterator pointing to the first element in reverse order (last element in normal order).  <a href="classring__buffer.html#aa243a80e8756739ce4b64f73e9a4338e">More...</a><br /></td></tr>
<tr class="separator:aa243a80e8756739ce4b64f73e9a4338e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109b2e943558eab49ca6d33ca398a838"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a109b2e943558eab49ca6d33ca398a838">crbegin</a> () const</td></tr>
<tr class="memdesc:a109b2e943558eab49ca6d33ca398a838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reverse iterator pointing to the first element in reverse order (last element in normal order).  <a href="classring__buffer.html#a109b2e943558eab49ca6d33ca398a838">More...</a><br /></td></tr>
<tr class="separator:a109b2e943558eab49ca6d33ca398a838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ee796bf66742e0d25716ce4c9d6f5d"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a81ee796bf66742e0d25716ce4c9d6f5d">rend</a> ()</td></tr>
<tr class="memdesc:a81ee796bf66742e0d25716ce4c9d6f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order).  <a href="classring__buffer.html#a81ee796bf66742e0d25716ce4c9d6f5d">More...</a><br /></td></tr>
<tr class="separator:a81ee796bf66742e0d25716ce4c9d6f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dcf3f2bfc1c9be3d18ab2d25eebd48"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#ae9dcf3f2bfc1c9be3d18ab2d25eebd48">rend</a> () const</td></tr>
<tr class="memdesc:ae9dcf3f2bfc1c9be3d18ab2d25eebd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order).  <a href="classring__buffer.html#ae9dcf3f2bfc1c9be3d18ab2d25eebd48">More...</a><br /></td></tr>
<tr class="separator:ae9dcf3f2bfc1c9be3d18ab2d25eebd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a25432bd918d4cafbfb9e5bd47ea296"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a8a25432bd918d4cafbfb9e5bd47ea296">crend</a> () const</td></tr>
<tr class="memdesc:a8a25432bd918d4cafbfb9e5bd47ea296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order).  <a href="classring__buffer.html#a8a25432bd918d4cafbfb9e5bd47ea296">More...</a><br /></td></tr>
<tr class="separator:a8a25432bd918d4cafbfb9e5bd47ea296"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a15bc4c9d1486b1fcd9b8c5f7956b3d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classring__buffer.html#a15bc4c9d1486b1fcd9b8c5f7956b3d4c">swap</a> (<a class="el" href="classring__buffer.html">ring_buffer</a> &amp;a, <a class="el" href="classring__buffer.html">ring_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a15bc4c9d1486b1fcd9b8c5f7956b3d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Friend swap.  <a href="classring__buffer.html#a15bc4c9d1486b1fcd9b8c5f7956b3d4c">More...</a><br /></td></tr>
<tr class="separator:a15bc4c9d1486b1fcd9b8c5f7956b3d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt;<br />
class ring_buffer&lt; T, Allocator &gt;</h3>

<p>Dynamic Ringbuffer is a dynamically growing circular AllocatorAware std::container with support for queue, stack and priority queue adaptor functionality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Allocator used for (de)allocation and (de)construction. Defaults to std::allocator&lt;T&gt; </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3f9101235ae01592332386c047e17d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9101235ae01592332386c047e17d0d">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section post"><dt>Postcondition</dt><dd>this-&gt;<a class="el" href="classring__buffer.html#aa8e1113807a6554022cee5af36d3e1f0" title="Check if buffer is empty.">empty()</a> == true. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if there is not enough memory available for allocation. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a4995dd6a70c19f3fb90e17a3c0d2daa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4995dd6a70c19f3fb90e17a3c0d2daa4">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with a custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Custom allocator for the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>this-&gt;<a class="el" href="classring__buffer.html#aa8e1113807a6554022cee5af36d3e1f0" title="Check if buffer is empty.">empty()</a> == true. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if there is not enough memory available for allocation, or some exception from T's constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a2449de34e9c4a70e81c5c76a1a75e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2449de34e9c4a70e81c5c76a1a75e71f">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the buffer to a given size with given values and optionally a custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Amount of elements to be initialized in the buffer. </td></tr>
    <tr><td class="paramname">val</td><td>Reference to a value which the elements are initialized to. </td></tr>
    <tr><td class="paramname">alloc</td><td>Custom allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T needs to satisfy CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>std::distance(<a class="el" href="classring__buffer.html#a4a2abcc16c769e390ed5fc16b320cce7" title="Construct iterator at begin.">begin()</a>, <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>) == <a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5" title="Gets the size of the container.">size()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Allocates memory for count + allocBuffer elements. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if there is not enough memory available for allocation, or some exception from T's constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to amount of constructed elements (O(n)). </p>

</div>
</div>
<a id="a2648ee9dbe34781862260df46ac0d1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2648ee9dbe34781862260df46ac0d1e5">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom constructor. Initializes a buffer with count amount of default constructed value_type elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>amount of default constructed value_type elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must satisfy DefaultInsertable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if there is not enough memory available for allocation, or some exception from T's constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown the buffer will be in a valid but unexpected state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to count (O(n)). </p>

</div>
</div>
<a id="a34d43ed1b6357105e41d7811d5da6638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d43ed1b6357105e41d7811d5da6638">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename  = std::enable_if_t&lt;std::is_convertible&lt;typename std::iterator_traits&lt;InputIt&gt;::value_type,value_type&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>beginIt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>endIt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the buffer from range [begin,end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginIt</td><td>Iterator to first element of range. </td></tr>
    <tr><td class="paramname">endIt</td><td>Iterator pointing to past-the-last element of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>valye_type must satisfy CopyInsertable. InputIt must be deferencable to value_type, and incrementing rangeBegin (repeatedly) must reach rangeEnd. Otherwise behaviour is undefined. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc, or something from T's CopyConstructor if not NoThrowCopyConstructible. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown no memory is leaked and program remains in a valid state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to the size of the range (O(n)). </p><dl class="section note"><dt>Note</dt><dd>Behavior is undefined if elements in range are not valid. </dd></dl>

</div>
</div>
<a id="a37abccd052de210c36f6f397cd841a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37abccd052de210c36f6f397cd841a93">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list contructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the buffer from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must satisfy CopyInsertable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc, or something from T's CopyConstructor if not NoThrowCopyConstructible. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown no memory is leaked and program remains in a valid state. (Basic exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to initializer list size (O(n)). </p>

</div>
</div>
<a id="ad8925b041c137104b31c975169dd05b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8925b041c137104b31c975169dd05b0">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Reference to a RingBuffer to create a copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this == <a class="el" href="classring__buffer.html" title="Dynamic Ringbuffer is a dynamically growing circular AllocatorAware std::container with support for q...">ring_buffer(rhs)</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc, or something from T's CopyConstructor if not NoThrowCopyConstructible. @except If any exception is thrown, invariants are preserved.(Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size. </p>

</div>
</div>
<a id="af1e0d47fef23cc18aaa59b0447799b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e0d47fef23cc18aaa59b0447799b18">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Reference to a RingBuffer to create a copy from. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator for the new buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this == <a class="el" href="classring__buffer.html" title="Dynamic Ringbuffer is a dynamically growing circular AllocatorAware std::container with support for q...">ring_buffer(rhs)</a> but with a different allocator. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc, or something from T's CopyConstructor if not NoThrowCopyConstructible. @except If any exception is thrown, invariants are preserved.(Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size. </p>

</div>
</div>
<a id="a232425cc3a36aeb1a844956fd93623f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232425cc3a36aeb1a844956fd93623f0">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Rvalue reference to other buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ac2bcb469aba7cabbc293495eea355e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bcb469aba7cabbc293495eea355e6d">&#9670;&nbsp;</a></span>ring_buffer() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::<a class="el" href="classring__buffer.html">ring_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with different allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Rvalue reference to other buffer. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator for the new ring buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae747ef0e5bac6c9ee2eb4c3e7b728588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae747ef0e5bac6c9ee2eb4c3e7b728588">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the elements in the buffer with given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>Size of the buffer after the assignment. </td></tr>
    <tr><td class="paramname">value</td><td>Value of all elements after the assignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All existing references, pointers and iterators are to be considered invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is throw, no memory is leaked but buffer will be in valid but unexpected state (Basic Exception Guarantee). If more memory is allocated and exception is thrown, function has no effect (Strong exception guarantee)</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity. Calls destructor for each element in buffer and amount times values constructor. </p>

</div>
</div>
<a id="a2ff5b379f041a4f7ff1cfc8a2a8f69c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff5b379f041a4f7ff1cfc8a2a8f69c5">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>sourceBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>sourceEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the elements in the buffer with copy of [sourceBegin, sourceEnd) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceBegin</td><td>Iterator to beginning of the range. </td></tr>
    <tr><td class="paramname">sourceEnd</td><td>Past the end iterator of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is CopyInsertable and elements of [sourceBegin, sourceEnd) are not in *this. InputIt must be dereferenceable to value_type, and incrementing sourceBegin (repeatedly) must reach sourceEnd. Otherwise behaviour is undefined. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All existing references, pointers and iterators are to be considered invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or something from value_types constructor if not nothrow. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is throw, no memory is leaked but buffer will be in valid but unexpected state (Basic Exception Guarantee). If more memory is allocated, in case of any exception the function does nothing (Strong Exception Guarantee)</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity. Calls destructor for each element in buffer and CopyConstructor for the assigned range. </p>

</div>
</div>
<a id="acf5e7138c98dc161fad55891ec10a35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5e7138c98dc161fad55891ec10a35b">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the elements in the buffer with copy of the initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Source of elements to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All existing references, pointers and iterators are to be considered invalid. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or something from value_types constructor if not nothrow. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is throw, no memory is leaked but buffer will be in valid but unexpected state (Basic Exception Guarantee). If more memory is allocated, in case of any exception the function does nothing (Strong Exception Guarantee)</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity. Calls destructor for each element in buffer and CopyConstructor for each element in the list. </p>

</div>
</div>
<a id="a15eb085b3f95fdedb1906f4fb9f22c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb085b3f95fdedb1906f4fb9f22c8f">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>logicalIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific element of the buffer with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalIndex</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference the the element at index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>std::out_of_range if index is larger or equal to buffers size. </td></tr>
    <tr><td class="paramname">If</td><td>any exceptions is thrown this function has no effect (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a988f02984769a27167341843f36060a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988f02984769a27167341843f36060a4">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>logicalIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific element of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalIndex</td><td>Index of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference the the element at index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>std::out_of_range if index is larger or equal to buffers size. </td></tr>
    <tr><td class="paramname">If</td><td>any exceptions is thrown this function has no effect (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a0661379f8b19f49d5e5d026455be9617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0661379f8b19f49d5e5d026455be9617">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const-reference to the last element in the buffer. Behaviour is undefined for empty buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the last element in the buffer.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ae7ca98342bbe89dd9aba19838cb7b407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ca98342bbe89dd9aba19838cb7b407">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the buffer. Behaviour is undefined for empty buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element in the buffer.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a8347b456303e02b7a9ee23312859a621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8347b456303e02b7a9ee23312859a621">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct const_iterator at begin. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator pointing to first element.</dd></dl>
<p>Constant complexity. Iterator is invalid if the buffer is empty (dereferencing points to uninitialized memory.). </p>

</div>
</div>
<a id="a4a2abcc16c769e390ed5fc16b320cce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2abcc16c769e390ed5fc16b320cce7">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct iterator at begin. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to first element.</dd></dl>
<p>Constant complexity. Iterator is invalid if the buffer is empty (dereferencing points to uninitialized memory.). </p>

</div>
</div>
<a id="aeb98388fa6ae8a7a86e968d95534c8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb98388fa6ae8a7a86e968d95534c8fd">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Capacity getter. </p>
<dl class="section return"><dt>Returns</dt><dd>m_capacity Returns how many elements have been allocated for the buffers use.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a9494413971913e7702426e7fe8968c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9494413971913e7702426e7fe8968c6a">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct const_iterator at begin. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator pointing to first element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a3bce1fcd742096534d78bc450371775a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bce1fcd742096534d78bc450371775a">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct const_iterator pointing to past the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator pointing past last element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a69a41fdbb783e1acf736ab5b3d154472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a41fdbb783e1acf736ab5b3d154472">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys all elements in a buffer. Does not modify capacity. </p>
<dl class="section post"><dt>Postcondition</dt><dd>All existing references, pointers and iterators are to be considered invalid.</dd></dl>
<p>Linear complexity in relation to size of the buffer. </p>

</div>
</div>
<a id="a109b2e943558eab49ca6d33ca398a838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109b2e943558eab49ca6d33ca398a838">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reverse iterator pointing to the first element in reverse order (last element in normal order). </p>
<p>Constant complexity. </p><dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the first element in reverse order. </dd></dl>

</div>
</div>
<a id="a8a25432bd918d4cafbfb9e5bd47ea296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a25432bd918d4cafbfb9e5bd47ea296">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order). </p>
<p>Constant complexity. </p><dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to one past the last element in reverse order. </dd></dl>

</div>
</div>
<a id="a5b078b39ae40a0c1bc0b4e60a81f67ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b078b39ae40a0c1bc0b4e60a81f67ac">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts ringbuffer so that logical tail matches the first element in physical memory. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the first element. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet MoveInsertable, or CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>&amp;this[0] == m_data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
    <tr><td class="paramname">If</td><td>T's Move (or copy in case T does not provide Move Semantics) constructor throws, behaviour is undefined. Otherwise if exceptions are thrown (std::bad_alloc) this function has no effect (Strong exception guarantee). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Invalidates all existing pointers and references.</dd></dl>
<p>Linear complexity in relation to buffer size. </p>

</div>
</div>
<a id="acefe57c42e075e935c20a4da038b7df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefe57c42e075e935c20a4da038b7df7">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an element in place from arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator before which the new element will be constructed. </td></tr>
    <tr><td class="paramname">args</td><td>Argument pack containing arguments to construct value_type element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator pointing to the element constructed from args. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet EmplaceConstructible, MoveAssignalbe and MoveInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterators, pointers and references are invalidated after the emplace point. If more memory is allocated, pointers and references to all elements are invalidated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if memory is allocated. Can also throw from T's constructor when constructing the element. Additionally, rotate can throw bad_alloc and if T does not provide a noexcept move semantics. </td></tr>
    <tr><td class="paramname">If</td><td>T's CopyConstructor is NoThrow then in case of any exception invariants are preserved. (Basic exception guarantee). If T's construction throws the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<p>Amortized linear complexity in relation to distance from pos to <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>. </p>

</div>
</div>
<a id="aed98662b3760dac1c9ea6c98d0106068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed98662b3760dac1c9ea6c98d0106068">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in place to front from argumets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Argument pack containing arguments to construct value_type element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is EmplaceConstructible from args. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if memory is allocated. Can also throw from T's constructor when constructing the element. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, function has no effect. (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Amortized constant complexity. </p>

</div>
</div>
<a id="a4a7e65ec20452b89d10f1a587fa39222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7e65ec20452b89d10f1a587fa39222">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in place to front from argumets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Argument pack containing arguments to construct value_type element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is EmplaceConstructible from args. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc if memory is allocated. Can also throw from T's constructor when constructing the element. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, function has no effect. (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Amortized constant complexity. </p>

</div>
</div>
<a id="aa8e1113807a6554022cee5af36d3e1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e1113807a6554022cee5af36d3e1f0">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if buffer is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if buffer is empty</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a8b3a0562418674a74bbc28eaa6ca793e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3a0562418674a74bbc28eaa6ca793e">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct const_iterator at end. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator pointing past last element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ab057216d2bd4ad43454758fb3eeed319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab057216d2bd4ad43454758fb3eeed319">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct iterator at end. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing past last element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a36c5e76881f854c9083ae3ea0083a3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c5e76881f854c9083ae3ea0083a3ea">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the specified elements from the container according to the range [first,last). Might destroy or move assign to the elements depending if last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>. If last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>, elements in [first,last) are destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first element to erase. </td></tr>
    <tr><td class="paramname">last</td><td>iterator past the last element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>First and last must be valid iterators to *this. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator to the element that was immediately following the last erased elements. If last == <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>, then new <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a> is returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Possibly</td><td>throws from value_types move/copy assignment operator if last != <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>. </td></tr>
    <tr><td class="paramname">If</td><td>value_type is nothrow_move_constructible and nothrow_move_assignable function is noexcept. Otherwisde provides no exception guarantee at all.</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to size of the range, and then linear in remaining elements after the erased range. </p>

</div>
</div>
<a id="ad68227da7f12db1402a6bce1cc8b834a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68227da7f12db1402a6bce1cc8b834a">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Pointer to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must be nothrow-MoveConstructible. pos must be a valid dereferenceable iterator within the container. Otherwise behavior is undefined. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator that was immediately following the ereased element. If the erased element was last in the buffer, returns a pointer to <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>value_type is nothrow_move_constructible and nothrow_move_assignable function is noexcept. Otherwise provides no exception guarantee at all.</td></tr>
  </table>
  </dd>
</dl>
<p>Linear Complexity in relation to distance of end buffer from the target element. </p>

</div>
</div>
<a id="a96289837a2a156411bddba7f214cce3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96289837a2a156411bddba7f214cce3a">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the buffer. Behaviour is undefined for empty buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reference to the first element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a6dee6af7622eafe9662e32f10d78b6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dee6af7622eafe9662e32f10d78b6b6">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the buffer. Behaviour is undefined for empty buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a527ba7169a95db0c12da90173963c2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527ba7169a95db0c12da90173963c2f9">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator getter. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the allocator used by the container.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="ae2d9f8150e7762f6661154d0e37dc6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d9f8150e7762f6661154d0e37dc6ca">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator where the the element should be inserted </td></tr>
    <tr><td class="paramname">count</td><td>Amount of T elements to be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet the requirements of CopyInsertable. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that pos to the inserted element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc, or something from T's copy constructor if not NoThrow. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, the function does nothing (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size and inserted elements. O(n). </p>

</div>
</div>
<a id="a6e9bf60beea284ff8ec7288526fbe95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9bf60beea284ff8ec7288526fbe95f">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator where the the element should be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the inserted value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet CopyInsertable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc, or something from T's copy constructor if not NoThrow. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, the function does nothing (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size and inserted elements. O(n). </p>

</div>
</div>
<a id="ab68cc324f43afbaef53a5f6dec8e8f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68cc324f43afbaef53a5f6dec8e8f79">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>sourceBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>sourceEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a range of elements into the buffer to a specific position. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>Type of iterator for the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>A valid dereferenceable iterator to the position where range will be inserted to. </td></tr>
    <tr><td class="paramname">sourceBegin</td><td>Iterator to first element of the range. </td></tr>
    <tr><td class="paramname">sourceEnd</td><td>Iterator past the last element of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator to an element in the buffer which is copy of the first element in the range. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet requirements of CopyInsertable. Iterators must point to elements that are implicitly convertible to value_type and sourceEnd must be reachable from sourceBegin. Otherwise behavior is undefined. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or something from value_types constructor and iterator operations. </td></tr>
    <tr><td class="paramname">If</td><td>any exceptiong is thrown, the function does nothing (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size and inserted elements. O(n). </p>

</div>
</div>
<a id="acd0d87d9c657e5356151da13ab78e444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0d87d9c657e5356151da13ab78e444">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts initializer list into buffer to a specific position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator where the list will be inserted. </td></tr>
    <tr><td class="paramname">list</td><td>Initiliazer list to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>pos must be a valid dereferenceable iterator within the container. Otherwise behavior is undefined. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns Iterator to the first element inserted, or the element pointed by pos if the initializer list was empty. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc and something from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exceptiong is thrown, the function does nothing (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size and inserted elements. O(n). </p>

</div>
</div>
<a id="af647fe55fa023f8b9b6e948350c09ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af647fe55fa023f8b9b6e948350c09ffe">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer_1_1__rBuf__iterator.html">iterator</a> <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer_1_1__rBuf__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator where the the element should be inserted </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator that pos to the inserted element. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet MoveInsertable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc, or something from T's move/copy constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, the function does nothing (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size and inserted elements. O(n). </p>

</div>
</div>
<a id="a09435a2152f9b680154e1e51e4472787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09435a2152f9b680154e1e51e4472787">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the theoretical maximum size of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum size of the buffer.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a75342dd634240adde461810a0cee4504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75342dd634240adde461810a0cee4504">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&amp; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Ringbuffer to be copy assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns reference to the assignment target container. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*this == other. All iterators, pointers and references of the target container should be considered invalid. Does not guarantee that target containers capacity equals the original. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc or something from value_types constructor. </td></tr>
    <tr><td class="paramname">If</td><td>any exception is thrown, invariants are retained and no memory is leaked (Basic Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to buffer size. <br  />
 </p>

</div>
</div>
<a id="a124ac4c5e7a58fde1379ffb40dac39ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124ac4c5e7a58fde1379ffb40dac39ef">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&amp; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Rvalue ref to other buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type is MoveConstructible. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*this has values other had before the assignment. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the buffer to move from. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>value_type is not MoveConstructible, and if value_type provides a throwing CopyConstructor this function has undefined behaviour.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a89969f6013137b1cda7489ae422759f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89969f6013137b1cda7489ae422759f1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classring__buffer.html">ring_buffer</a>&amp; <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list assign operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to assign to the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the buffer. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>T is CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All existing iterators are invalidated. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally calls <a class="el" href="classring__buffer.html#a2ff5b379f041a4f7ff1cfc8a2a8f69c5" title="Replaces the elements in the buffer with copy of [sourceBegin, sourceEnd)">assign()</a>, which destroys all elements before CopyInserting from initializer list.</dd></dl>
<p>Linear complexity in relation to amount of existing elements and size of initializer list. </p>

</div>
</div>
<a id="a3bbae1471c094bf84d8f1950a525e513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbae1471c094bf84d8f1950a525e513">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>logicalIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalIndex</td><td>Index of the element used to access n:th element of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity </p><dl class="section note"><dt>Note</dt><dd>The operator acts as interface that hides the physical memory layout from the user. Logical index neeeds to be added to internal tail index to get actual element address. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a const reference the the element ad logicalIndex. </dd></dl>

</div>
</div>
<a id="a7c14c9afba67aad502b36653d1bbc2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c14c9afba67aad502b36653d1bbc2ca">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>logicalIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logicalIndex</td><td>Index of the element. If LogicalIndex &gt;= <a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5" title="Gets the size of the container.">size()</a>, this function has undefined behavriour.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p><dl class="section note"><dt>Note</dt><dd>The operator acts as interface that hides the physical memory layout from the user. Logical index neeeds to be added to internal tail index to get actual element address. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the element. </dd></dl>

</div>
</div>
<a id="ad1c703f9814872877775d2a5c2fef243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c703f9814872877775d2a5c2fef243">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an element from the logical back of the buffer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Buffers size &gt; 0, otherwise behaviour is undefined. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All pointers and references are invalidated. Iterators persist except <a class="el" href="classring__buffer.html#ab057216d2bd4ad43454758fb3eeed319" title="Construct iterator at end.">end()</a> - 1 iterator is invalidated (it becomes new past-the-last iterator).</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="aef28bc848394b3bc6a1dea129dbb412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef28bc848394b3bc6a1dea129dbb412f">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first element in the buffer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Buffers size &gt; 0, otherwise behaviour is undefined. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All iterators, pointers and references are invalidated.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a3de0c8df71d288b2948d618bdd930250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de0c8df71d288b2948d618bdd930250">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element in the back of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value of T to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If buffer would get full after the operation, allocates more memory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
    <tr><td class="paramname">If</td><td>the copy constructor of value_type throws, behaviour is undefined. Otherwise in case of exception this function has no effect (Strong Exception Guarantee). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type must satisfy CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If more memory is allocated all pointers, iterators and references are invalidated.</dd></dl>
<p>Amoprtized constant complexity. </p>

</div>
</div>
<a id="a7d8ed70b4ef81563f9e8d349f256d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8ed70b4ef81563f9e8d349f256d84c">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element in the back of the buffer by move if move constructor is provided for value_type. </p>
<dl class="section note"><dt>Note</dt><dd>If buffer would get full after the operation more memory is allocated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Rvalue reference to the value to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
    <tr><td class="paramname">If</td><td>the move/copy constructor of value_type throws, behaviour is undefined. Otherwise in case of any exception this function has no effect (Strong Exception Guarantee). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type needs to satisfy MoveInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If more memory is allocated all pointers, iterators and references are invalidated.</dd></dl>
<p>Amortized constant complexity. </p>

</div>
</div>
<a id="a4bed0fe915650f882f772d022f89bc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bed0fe915650f882f772d022f89bc0b">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element in the back of the buffer. </p>
<dl class="section note"><dt>Note</dt><dd>If buffer would get full after the operation, function allocates more memory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Element to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must satisfy CopyInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All iterators are invalidated. If more memory is allocated, all pointers and references are invalidated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the copy constructor of value_type throws, behaviour is undefined. Otherwise in case of any exception this function has no effect (Strong Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Amortized constant complexity. </p>

</div>
</div>
<a id="ab2d27891d77e19442f1d8acaa26b11ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d27891d77e19442f1d8acaa26b11ee">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element in the back of the buffer by move if move constructor is provided by value_type. </p>
<dl class="section note"><dt>Note</dt><dd>If buffer would get full after the operation, allocates more memory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Rvalue reference to the element to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>value_type needs to satisfy MoveInsertable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All iterators are invalidated. If more memory is allocated, all pointers and references are invalidated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the move constructor of value_type throws, behaviour is undefined. Otherwise in case of any exception this function has no effect (Strong Exception Guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Amortized constant complexity. </p>

</div>
</div>
<a id="ab456f054b5903b00e9b23ecf0b93675d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab456f054b5903b00e9b23ecf0b93675d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reverse iterator pointing to the first element in reverse order (last element in normal order). </p>
<dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to first element in reverse order.</dd></dl>
<p>Constant complexity. Iterator is invalid if the buffer is empty (dereferencing points to uninitialized memory.). </p>

</div>
</div>
<a id="aa243a80e8756739ce4b64f73e9a4338e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa243a80e8756739ce4b64f73e9a4338e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reverse iterator pointing to the first element in reverse order (last element in normal order). </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to the first element in reverse order.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="a81ee796bf66742e0d25716ce4c9d6f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ee796bf66742e0d25716ce4c9d6f5d">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order). </p>
<p>Constant complexity. </p><dl class="section return"><dt>Returns</dt><dd>reverse_iterator pointing to one past the last element in reverse order. </dd></dl>

</div>
</div>
<a id="ae9dcf3f2bfc1c9be3d18ab2d25eebd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dcf3f2bfc1c9be3d18ab2d25eebd48">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reverse iterator pointing to one past the last element in reverse order (one before the first element in normal order). </p>
<p>Constant complexity. </p><dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to one past the last element in reverse order. </dd></dl>

</div>
</div>
<a id="a8f6fd7a2d343de27c99761c6029f6d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6fd7a2d343de27c99761c6029f6d28">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableShrink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory and copies the existing buffer to the new memory location. Can be used to increase or decrease capacity. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>std::bad_alloc if there is not enough memory for allocation. Throws std::bad_array_new_lenght if std::numeric_limits&lt;std::size_t&gt;::max() / sizeof(T) &lt; newsize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>Amount of memory to allocate. If newCapacity is less than or equal to m_capacity, function does nothing. </td></tr>
    <tr><td class="paramname">enableShrink</td><td>True to enable reserve to reduce the capacity, to a minimum of <a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5" title="Gets the size of the container.">size()</a> +2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>T must meet MoveInsertable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Can</td><td>throw std::bad_alloc. </td></tr>
    <tr><td class="paramname">If</td><td>T's move (or copy if T has no move) constructor throws, behaviour is undefined. Otherwise Stong Exception Guarantee. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All references, pointers and iterators are invalidated. If memory is allocated, the memory layout is rotated so that first element matches the beginning of physical memory.</dd></dl>
<p>Linear complexity in relation to size of the buffer (O(n)). </p>

</div>
</div>
<a id="a4404cf478938dc61b93a963581bd2f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4404cf478938dc61b93a963581bd2f3a">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases unused allocated memory. </p>
<dl class="section pre"><dt>Precondition</dt><dd>T must satisfy MoveConstructible or CopyConstructible. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>m_capacity == <a class="el" href="classring__buffer.html#aca0782fc0b1264ff01c5ffbe199423a5" title="Gets the size of the container.">size()</a> + allocBuffer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reduces capacity by allocating a smaller memory area and moving the elements. Shrinking the buffer invalidates all pointers, iterators and references. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Might</td><td>throw std::bad_alloc if memory allocation fails. </td></tr>
    <tr><td class="paramname">If</td><td>T's move (or copy) constructor can and does throw, behaviour is undefined. If any other exception is thrown (bad_alloc) this function has no effect (Strong exception guarantee).</td></tr>
  </table>
  </dd>
</dl>
<p>Linear complexity in relation to size of the buffer. </p>

</div>
</div>
<a id="aca0782fc0b1264ff01c5ffbe199423a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0782fc0b1264ff01c5ffbe199423a5">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of buffer.</dd></dl>
<p>Constant complexity. </p>

</div>
</div>
<a id="aa53ef9bfdabd3a5e613413b27c66de61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53ef9bfdabd3a5e613413b27c66de61">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Member swap implementation. Swaps RingBuffers member to member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Reference to a <a class="el" href="classring__buffer.html" title="Dynamic Ringbuffer is a dynamically growing circular AllocatorAware std::container with support for q...">ring_buffer</a> to swap with.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p><dl class="section note"><dt>Note</dt><dd>Requires allocator_type to return true_type from propagate_on_container_swap, otherwise memory operations <br  />
 </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a15bc4c9d1486b1fcd9b8c5f7956b3d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bc4c9d1486b1fcd9b8c5f7956b3d4c">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classring__buffer.html">ring_buffer</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Friend swap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Swap candidate. </td></tr>
    <tr><td class="paramname">b</td><td>Swap candidate.</td></tr>
  </table>
  </dd>
</dl>
<p>Constant complexity. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="ring__buffer_8hpp_source.html">ring_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
